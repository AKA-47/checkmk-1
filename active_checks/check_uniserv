#!/usr/bin/env python
# -*- encoding: utf-8; py-indent-offset: 4 -*-
# +------------------------------------------------------------------+
# |             ____ _               _        __  __ _  __           |
# |            / ___| |__   ___  ___| | __   |  \/  | |/ /           |
# |           | |   | '_ \ / _ \/ __| |/ /   | |\/| | ' /            |
# |           | |___| | | |  __/ (__|   <    | |  | | . \            |
# |            \____|_| |_|\___|\___|_|\_\___|_|  |_|_|\_\           |
# |                                                                  |
# | Copyright Mathias Kettner 2014             mk@mathias-kettner.de |
# +------------------------------------------------------------------+
#
# This file is part of Check_MK.
# The official homepage is at http://mathias-kettner.de/check_mk.
#
# check_mk is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# tails. You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.

import sys
import socket


def parse_response(data):
    try:
        parsed = dict([x.split('=') for x in data.split(";")][:-1])
        response_type = parsed['type']
    except (ValueError, KeyError):
        sys.stdout.write("Invalid data: %s\n" % data)
        sys.exit(3)

    if response_type == '1':
        sys.stdout.write("Invalid response: %s\n" % data)
        sys.exit(3)
    return parsed


def send_and_receive(sock, request_str):
    sock.send(request_str)
    answer = sock.recv(1024)
    return parse_response(answer)


def parse_arguments(sys_args):
    if sys_args is None:
        sys_args = sys.argv[1:]

    host = None
    tcp_port = None
    service = None
    job = None
    street = None
    street_nr = None
    city = None
    regex = None
    try:
        host = sys_args[0]
        tcp_port = int(sys_args[1])
        service = sys_args[2]
        job = sys_args[3]
        if job == "ADDRESS":
            street = sys_args[4]
            street_nr = sys_args[5]
            city = sys_args[6]
            regex = sys_args[7]
    except (IndexError, ValueError):
        sys.stdout.write(
            " Usage: check_uniserv HOSTNAME PORT SERVICE (VERSION|ADDRESS STREET NR CITY SEARCH_REGEX)\n"
        )
        sys.exit(3)

    return host, tcp_port, service, job, street, street_nr, city, regex


def main(sys_args=None):

    host, tcp_port, service, job, street, street_nr, city, regex = parse_arguments(sys_args)

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host, tcp_port))

    sendstring = "open:service=" + service + ";servicehost=" + host + "\n"
    data = send_and_receive(s, sendstring)
    if not data.get('session'):
        return 3, "Error getting SID. Response was: %s\n" % data

    sid = data.get('session')

    if job == "VERSION":
        sendstring = "version:session=" + sid + "\n"
        data = send_and_receive(s, sendstring)
        state = 0
        infotext = "Version is " + data['version_str']
    elif job == "ADDRESS":
        import re
        sendstring = "exec:session=%s;request_type=check_address;in_str=%s;in_hno=%s;in_city=%s\n" % (
            sid,
            street,
            street_nr,
            city,
        )
        _data = send_and_receive(s, sendstring)

        sendstring = "fetch:session=" + sid + ";out_zip=?;out_city=?\n"
        data = send_and_receive(s, sendstring)

        state = 0
        infotext = "Address is %s %s" % (data['out_zip'], data['out_city'])
        if not re.match(regex, data['out_city']):
            infotext += " But excpects %s" % regex
            state = 2
    else:
        state = 3
        infotext = "JOB not known"

    s.send("close:session=" + sid + "\n")
    s.close()

    return state, "%s\n" % infotext


if __name__ == "__main__":
    exitcode, info = main()
    sys.stdout.write("%s\n" % info)
    sys.exit(exitcode)

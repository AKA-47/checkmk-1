#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright (C) 2019 tribe29 GmbH - License: GNU General Public License v2
# This file is part of Checkmk (https://checkmk.com). It is subject to the terms and
# conditions defined in the file COPYING, which is part of this source code package.
"""Email server roundtrip active check
"""

# Cleanup includes
# [x] argparse
# [x] global objects
# [ ] structural refactoring
# [ ] typing

import ast
import email
import email.mime.text
import email.utils
import argparse
import imaplib
import os
import poplib
import random
import re
import smtplib
import sys
import time

import cmk.utils.password_store

# The documentations of imaplib and poplib do not give any information about the encodings of their
# outputs (e.g. of imaplib.IMAP4.search). From the source codes, it seems to be either ASCII or
# UTF-8, so this should work.
ENCODING = 'utf-8'


class FetchMailsError(Exception):
    pass


class SendMailError(Exception):
    pass


class CleanupMailboxError(Exception):
    pass


class ForwardToECError(Exception):
    pass


def parse_arguments(argv):
    """Parse command line arguments and return argument object"""
    parser = argparse.ArgumentParser(description=__doc__,
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument("--debug",
                        "-d",
                        action="store_true",
                        help="Enable debug mode (keep some exceptions unhandled)")
    # TODO: seems to be unused
    parser.add_argument("--connect-timeout",
                        type=int,
                        default=10,
                        help="Timeout in seconds for network connects")

    parser.add_argument("--fetch-server",
                        type=str,
                        required=True,
                        metavar="ADDRESS",
                        help="Host address of the IMAP/POP3 server hosting your mailbox")
    parser.add_argument("--fetch-username",
                        type=str,
                        required=True,
                        metavar="USER",
                        help="Username to use for IMAP/POP3")
    parser.add_argument("--fetch-password",
                        type=str,
                        required=True,
                        metavar="PASSWORD",
                        help="Password to use for IMAP/POP3")
    parser.add_argument("--fetch-protocol",
                        type=str,
                        default="IMAP",
                        choices={'IMAP', 'POP3'},
                        help="Set to 'IMAP' or 'POP3', depending on your mailserver")
    parser.add_argument("--fetch-port",
                        type=int,
                        metavar="PORT",
                        help="IMAP or POP3 port (defaults to 110 for POP3 and 995 for POP3 "
                        "with TLS/SSL and 143 for IMAP and 993 for IMAP with TLS/SSL)")
    parser.add_argument("--fetch-tls",
                        action="store_true",
                        help="Use TLS/SSL for feching the mailbox (disabled by default)")

    parser.add_argument("--smtp-server",
                        type=str,
                        required=True,
                        metavar="ADDRESS",
                        help="Host address of the SMTP server to send the mail to")
    parser.add_argument("--smtp-port",
                        type=int,
                        metavar="PORT",
                        help='Port to use for SMTP (defaults to 25)')
    parser.add_argument("--smtp-username",
                        type=str,
                        metavar="USER",
                        help="Username to use for SMTP communictation "
                        "(leave empty for anonymous SMTP)")
    parser.add_argument("--smtp-password",
                        type=str,
                        metavar="PASSWORD",
                        help="Password to authenticate SMTP")
    parser.add_argument("--smtp-tls", action="store_true", help="Use TLS over SMTP")

    parser.add_argument("--mail-from",
                        type=str,
                        required=True,
                        help="Use this mail address as sender address")
    parser.add_argument("--mail-to",
                        type=str,
                        required=True,
                        help="Use this mail address as recipient address")

    parser.add_argument("--warning",
                        type=int,
                        metavar="AGE",
                        help="Loop duration of the most recent mail in seconds or the average of "
                        "all received mails within a single check to raise a WARNING state")
    parser.add_argument("--critical",
                        type=int,
                        metavar="AGE",
                        default=3600,
                        help="Loop duration in seconds of the most recent mail in seconds or the "
                        "average of all received mails within a single check to raise a "
                        "CRITICAL state")

    default_status_dir = ((os.environ["OMD_ROOT"] + "/var/check_mk")  #
                          if "OMD_ROOT" in os.environ else "/tmp")
    parser.add_argument("--status-dir",
                        type=str,
                        metavar="PATH",
                        default=default_status_dir,
                        help="This plugin needs a file to store information about sent, received "
                        "and expected mails. Defaults to either '/tmp/' or "
                        "'/omd/sites/<sitename>/var/check_mk' when executed from within an "
                        "OMD site")
    parser.add_argument("--status-suffix",
                        type=str,
                        metavar="SUFFIX",
                        help="Concantenated with 'check_mail_loop.SUFFIX.status' to generate "
                        "the name of the status file.")
    parser.add_argument("--delete-messages",
                        action="store_true",
                        help="Delete all messages identified as being related to this check "
                        "plugin. This is disabled by default, which might make your mailbox "
                        "grow when you not clean it up manually.")
    parser.add_argument("--subject",
                        type=str,
                        metavar="SUBJECT",
                        default="Check_MK-Mail-Loop",
                        help="You can specify the subject text.")

    parser.add_argument("--verbose", '-v', action="count", default=0)

    args = parser.parse_args(argv)
    args.fetch_port = args.fetch_port or (
        (995 if args.fetch_tls else 110) if args.fetch_protocol == 'POP3' else
        (993 if args.fetch_tls else 143))
    return args


def parse_exception(exc):
    exc = str(exc)
    if exc[0] == '{':
        exc = "%d - %s" % list(ast.literal_eval(exc).values())[0]
    return str(exc)


def output_check_result(rc, s, perfdata):
    stxt = ['OK', 'WARN', 'CRIT', 'UNKNOWN'][rc]
    output = '%s - %s' % (stxt, s)
    if perfdata:
        perfdata_output_entries = ['%s=%s' % (p[0], ';'.join(map(str, p[1:]))) for p in perfdata]
        output += ' | %s' % " ".join(perfdata_output_entries)
    sys.stdout.write('%s\n' % output)


def load_expected_mails(status_path):
    try:
        expected_mails = {}
        for line in open(status_path):
            ts, key = line.rstrip().split(' ', 1)
            expected_mails[ts + '-' + key] = (int(ts), int(key))
        return expected_mails
    except IOError:
        # Skip errors on not existing file
        return {}


def add_expected_msg(ts, key, expected_mails):
    expected_mails[str(ts) + '-' + str(key)] = (int(ts), key)


def save_expected_mails(expected_mails, status_path):
    lines = []
    for ts, key in expected_mails.values():
        lines.append('%d %s' % (ts, key))
    open(status_path, 'w').write('\n'.join(lines) + '\n')


def send_mail(args, expected_mails):
    now = time.time()
    key = random.randint(1, 1000)

    mail = email.mime.text.MIMEText("")
    mail['From'] = args.mail_from
    mail['To'] = args.mail_to
    mail['Subject'] = '%s %d %d' % (args.subject, now, key)
    mail['Date'] = email.utils.formatdate(localtime=True)

    try:
        S = smtplib.SMTP(args.smtp_server, args.smtp_port)
        if args.smtp_tls:
            S.starttls()
        if args.smtp_username:
            S.login(args.smtp_username, args.smtp_password)
        S.sendmail(args.mail_from, args.mail_to, mail.as_string())
        S.quit()

        add_expected_msg(now, key, expected_mails)

    except Exception as e:
        if args.debug:
            raise
        raise SendMailError('Failed to send mail: %s' % parse_exception(e))


def check_mails(warning, critical, expected_mails, fetched_mails):
    state = 0
    perfdata = []
    output = []

    num_received = 0
    num_pending = 0
    num_lost = 0
    duration = None
    now = time.time()

    # Loop all expected mails and check whether or not they have been received
    for ident, (send_ts, _unused_key) in sorted(expected_mails.items()):
        if ident in fetched_mails:
            recv_ts = fetched_mails[ident][1]

            if duration is None:
                duration = recv_ts - send_ts
            else:
                duration = (duration + (recv_ts - send_ts)) / 2.0  # average

            if critical is not None and duration >= critical:
                state = 2
            elif warning is not None and duration >= warning:
                state = max(state, 1)

            if state:
                output.append(' (warn/crit at %s/%s)' % (warning, critical))

            del expected_mails[ident]  # remove message from expect list
            num_received += 1
            # FIXME: Also remove older mails which have not yet been seen?

        else:
            # drop expecting messages when older than critical threshold,
            # but keep waiting for other mails which have not yet reached it
            if now - send_ts >= critical:
                del expected_mails[ident]
                num_lost += 1
                state = 2
            else:
                num_pending += 1

    if num_received == 1:
        output.insert(0, 'Mail received within %d seconds' % (0 if duration is None else duration))
        perfdata.append(('duration', duration, warning or '', critical or ''))
    elif num_received > 1:
        output.insert(
            0, 'Received %d mails within average of %d seconds' %
            (num_received, (0 if duration is None else duration)))
        perfdata.append(('duration', duration, warning or '', critical or ''))
    else:
        output.insert(0, 'Did not receive any new mail')

    if num_lost:
        output.append('Lost: %d (Did not arrive within %d seconds)' % (num_lost, critical))

    if num_pending:
        output.append('Currently waiting for %d mails' % num_pending)

    return state, ", ".join(output), perfdata


class MailBox:
    def __init__(self, args):
        #g_M: Union[None, poplib.POP3, imaplib.IMAP4] = None
        self._mailbox = None
        self._args = args

    def __enter__(self):
        return self

    def __exit__(self, *exc):
        self._close_mailbox()
        return False

    def fetch_mails(self, expected_mails):
        if not expected_mails:
            # not expecting any mail, do not check for mails
            return {}, {}

        try:
            mails = {}
            if self._args.fetch_protocol == 'POP3':
                # Get mails from POP3 mailbox
                self._mailbox = poplib.POP3_SSL(
                    self._args.fetch_server,
                    self._args.fetch_port) if self._args.fetch_ssl else poplib.POP3(
                        self._args.fetch_server, self._args.fetch_port)
                self._mailbox.user(self._args.fetch_username)
                self._mailbox.pass_(self._args.fetch_password)

                num_messages = len(self._mailbox.list()[1])

                for i in range(num_messages):
                    index = i + 1
                    lines = self._mailbox.retr(index)[1]
                    mails[i] = email.message_from_bytes(b"\n".join(lines))

            else:
                # Get mails from IMAP mailbox
                self._mailbox = imaplib.IMAP4_SSL(
                    self._args.fetch_server,
                    self._args.fetch_port) if self._args.fetch_tls else imaplib.IMAP4(
                        self._args.fetch_server, self._args.fetch_port)

                self._mailbox.login(self._args.fetch_username, self._args.fetch_password)
                self._mailbox.select('INBOX', readonly=False)  # select INBOX
                retcode, raw_messages = self._mailbox.search(None, 'NOT', 'DELETED')
                messages = raw_messages[0].decode(ENCODING).strip()
                if retcode == 'OK' and messages:
                    for num in messages.split():
                        try:
                            _type, data = self._mailbox.fetch(num, '(RFC822)')
                            if isinstance(data[0], tuple):
                                mails[num] = email.message_from_bytes(data[0][1])
                        except Exception as e:
                            raise Exception('Failed to fetch mail %s (%s). Available messages: %r' %
                                            (num, parse_exception(e), messages))

            obsolete_mails = {}
            fetched_mails = {}
            # Now filter out the messages for this check
            pattern = re.compile(r'(?:Re: |WG: )?%s ([^\s]+) ([^\s]+)' % self._args.subject)
            for index, msg in mails.items():
                matches = pattern.match(msg.get('Subject', ''))
                if matches:
                    ts = matches.group(1).strip()
                    key = matches.group(2).strip()

                    # extract received time
                    rx = msg.get('Received')
                    if rx:
                        parsed = email.utils.parsedate_tz(rx.split(';')[-1])
                        rx_ts = int(
                            time.time()) if parsed is None else email.utils.mktime_tz(parsed)
                    else:
                        # use current time as fallback where no Received header could be found
                        rx_ts = int(time.time())

                    if "%s-%s" % (ts, key) not in expected_mails:
                        # Delete any "Check_MK-Mail-Loop" messages older than 24 hours, even if
                        # they are not in our list
                        if self._args.delete_messages and int(time.time()) - rx_ts > 24 * 3600:
                            obsolete_mails[ts + '-' + key] = (index, rx_ts)
                        continue

                    fetched_mails[ts + '-' + key] = (index, rx_ts)
            return obsolete_mails, fetched_mails

        except Exception as e:
            if self._args.debug:
                raise
            raise FetchMailsError('Failed to check for mails: %s' % parse_exception(e))

    def cleanup_mailbox(self, obsolete_mails, fetched_mails):
        if not self._mailbox:
            return  # do not deal with mailbox when none sent yet

        try:
            # Do not delete all messages in the inbox. Only the ones which were
            # processed before! In the meantime there might be occured new ones.
            for mail_index, _unused_recv_ts in list(fetched_mails.values()) + list(
                    obsolete_mails.values()):
                if isinstance(self._mailbox, poplib.POP3):
                    response = self._mailbox.dele(mail_index + 1).decode(ENCODING)
                    if not response.startswith("+OK"):
                        raise Exception("Response from server: [%s]" % response)
                elif isinstance(self._mailbox, imaplib.IMAP4):
                    response = self._mailbox.store(mail_index, '+FLAGS', '\\Deleted')[0]
                    if response != 'OK':
                        raise Exception("Response from server: [%s]" % response)

            if isinstance(self._mailbox, imaplib.IMAP4):
                self._mailbox.expunge()

        except Exception as e:
            if self._args.debug:
                raise
            raise CleanupMailboxError('Failed to delete mail: %s' % parse_exception(e))

    def _close_mailbox(self):
        if isinstance(self._mailbox, poplib.POP3):
            self._mailbox.quit()
        elif isinstance(self._mailbox, imaplib.IMAP4):
            self._mailbox.close()
            self._mailbox.logout()


def main(sys_args=None):
    args = parse_arguments(sys_args or sys.argv[1:])
    # Enable showing protocol messages of imap for debugging
    if args.fetch_protocol == 'IMAP' and args.debug:
        # Bug in mypy's typeshed.
        imaplib.Debug = 4  # type: ignore[attr-defined]

    try:
        status_path = '%s/check_mail_loop%s.status' % (args.status_dir, (".%s" % args.status_suffix)
                                                       if args.status_suffix else "")
        expected_mails = load_expected_mails(status_path)

        with MailBox(args) as mailbox:
            obsolete_mails, fetched_mails = mailbox.fetch_mails(expected_mails)
            send_mail(args, expected_mails)
            state, output, perfdata = check_mails(
                args.warning,
                args.critical,
                expected_mails,
                fetched_mails,
            )
            if args.delete_messages:
                mailbox.cleanup_mailbox(obsolete_mails, fetched_mails)

        save_expected_mails(expected_mails, status_path)
        return state, output, perfdata

    except FetchMailsError as e:
        return 3, str(e), None

    except SendMailError as e:
        return 3, str(e), None

    except CleanupMailboxError as e:
        return 2, str(e), None

    except Exception as e:
        if args.debug:
            raise
        return 2, 'Unhandled exception: %s' % parse_exception(e), None


if __name__ == "__main__":
    cmk.utils.password_store.replace_passwords()
    exitcode, info, perf = main()
    output_check_result(exitcode, info, perf)
    sys.exit(exitcode)

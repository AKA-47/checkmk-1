#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright (C) 2019 tribe29 GmbH - License: GNU General Public License v2
# This file is part of Checkmk (https://checkmk.com). It is subject to the terms and
# conditions defined in the file COPYING, which is part of this source code package.
"""Email server roundtrip active check
"""

# Cleanup includes
# [x] argparse
# [ ] global objects
# [ ] typing

import ast
import email
import email.mime.text
import email.utils
import argparse
import imaplib
import os
import poplib
import random
import re
import smtplib
import socket
import ssl
import sys
import time

import cmk.utils.password_store

# The documentations of imaplib and poplib do not give any information about the encodings of their
# outputs (e.g. of imaplib.IMAP4.search). From the source codes, it seems to be either ASCII or
# UTF-8, so this should work.
ENCODING = 'utf-8'


class FetchMailsError(Exception):
    pass


class SendMailError(Exception):
    pass


class CleanupMailboxError(Exception):
    pass


class ForwardToECError(Exception):
    pass


def parse_arguments(argv):
    """Parse command line arguments and return argument object"""
    parser = argparse.ArgumentParser(description=__doc__,
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument("--debug",
                        "-d",
                        action="store_true",
                        help="Enable debug mode (keep some exceptions unhandled)")
    # TODO: seems to be unused
    parser.add_argument("--connect-timeout",
                        type=int,
                        default=10,
                        help="Timeout in seconds for network connects")

    parser.add_argument("--fetch-server",
                        type=str,
                        required=True,
                        metavar="ADDRESS",
                        help="Host address of the IMAP/POP3 server hosting your mailbox")
    parser.add_argument("--fetch-username",
                        type=str,
                        required=True,
                        metavar="USER",
                        help="Username to use for IMAP/POP3")
    parser.add_argument("--fetch-password",
                        type=str,
                        required=True,
                        metavar="PASSWORD",
                        help="Password to use for IMAP/POP3")
    parser.add_argument("--fetch-protocol",
                        type=str,
                        default="IMAP",
                        choices={'IMAP', 'POP3'},
                        help="Set to 'IMAP' or 'POP3', depending on your mailserver")
    parser.add_argument("--fetch-port",
                        type=int,
                        metavar="PORT",
                        help="IMAP or POP3 port (defaults to 110 for POP3 and 995 for POP3 "
                        "with SSL and 143 for IMAP and 993 for IMAP with SSL)")
    # TODO: bad: should be called fetch-tls
    parser.add_argument("--fetch-ssl",
                        action="store_true",
                        help="Use SSL for feching the mailbox (disabled by default)")

    parser.add_argument("--smtp-server",
                        type=str,
                        required=True,
                        metavar="ADDRESS",
                        help="Host address of the SMTP server to send the mail to")
    parser.add_argument("--smtp-port",
                        type=int,
                        metavar="PORT",
                        help='Port to use for SMTP (defaults to 25)')
    parser.add_argument("--smtp-username",
                        type=str,
                        metavar="USER",
                        help="Username to use for SMTP communictation "
                        "(leave empty for anonymous SMTP)")
    parser.add_argument("--smtp-password",
                        type=str,
                        metavar="PASSWORD",
                        help="Password to authenticate SMTP")
    parser.add_argument("--smtp-tls", action="store_true", help="Use TLS over SMTP")

    # TODO: not used
    parser.add_argument("--imap-tls", action="store_true", help="Use TLS for IMAP authentification")

    parser.add_argument("--mail-from",
                        type=str,
                        required=True,
                        help="Use this mail address as sender address")
    parser.add_argument("--mail-to",
                        type=str,
                        required=True,
                        help="Use this mail address as recipient address")

    parser.add_argument("--warning",
                        type=int,
                        metavar="AGE",
                        help="Loop duration of the most recent mail in seconds or the average of "
                        "all received mails within a single check to raise a WARNING state")
    parser.add_argument("--critical",
                        type=int,
                        metavar="AGE",
                        default=3600,
                        help="Loop duration in seconds of the most recent mail in seconds or the "
                        "average of all received mails within a single check to raise a "
                        "CRITICAL state")

    default_status_dir = ((os.environ["OMD_ROOT"] + "/var/check_mk")  #
                          if "OMD_ROOT" in os.environ else "/tmp")
    parser.add_argument("--status-dir",
                        type=str,
                        metavar="PATH",
                        default=default_status_dir,
                        help="This plugin needs a file to store information about sent, received "
                        "and expected mails. Defaults to either '/tmp/' or "
                        "'/omd/sites/<sitename>/var/check_mk' when executed from within an "
                        "OMD site")
    parser.add_argument("--status-suffix",
                        type=str,
                        metavar="SUFFIX",
                        help="Concantenated with 'check_mail_loop.SUFFIX.status' to generate "
                        "the name of the status file.")
    parser.add_argument("--delete-messages",
                        action="store_true",
                        help="Delete all messages identified as being related to this check "
                        "plugin. This is disabled by default, which might make your mailbox "
                        "grow when you not clean it up manually.")
    parser.add_argument("--subject",
                        type=str,
                        metavar="SUBJECT",
                        default="Check_MK-Mail-Loop",
                        help="You can specify the subject text.")

    parser.add_argument("--verbose", '-v', action="count", default=0)

    args = parser.parse_args(argv)
    args.fetch_port = args.fetch_port or (
        (995 if args.fetch_ssl else 110) if args.fetch_protocol == 'POP3' else
        (993 if args.fetch_ssl else 143))
    return args


def parse_exception(exc):
    exc = str(exc)
    if exc[0] == '{':
        exc = "%d - %s" % list(ast.literal_eval(exc).values())[0]
    return str(exc)


def output_check_result(rc, s, perfdata):
    stxt = ['OK', 'WARN', 'CRIT', 'UNKNOWN'][rc]
    output = '%s - %s' % (stxt, s)
    if perfdata:
        perfdata_output_entries = ['%s=%s' % (p[0], ';'.join(map(str, p[1:]))) for p in perfdata]
        output += ' | %s' % " ".join(perfdata_output_entries)
    sys.stdout.write('%s\n' % output)


def load_expected_mails(status_path):
    try:
        expected_mails = {}
        for line in open(status_path):
            ts, key = line.rstrip().split(' ', 1)
            expected_mails[ts + '-' + key] = (int(ts), int(key))
        return expected_mails
    except IOError:
        # Skip errors on not existing file
        return {}


def add_expected_msg(ts, key, expected_mails):
    expected_mails[str(ts) + '-' + str(key)] = (int(ts), key)


def save_expected_mails(expected_mails, status_path):
    lines = []
    for ts, key in expected_mails.values():
        lines.append('%d %s' % (ts, key))
    open(status_path, 'w').write('\n'.join(lines) + '\n')


# TODO: not used
def add_starttls_support(self, conn_timeout):
    name = "STARTTLS"
    typ, dat = self._simple_command(name)
    if typ != 'OK':
        raise self.error(dat[-1])

    socket.setdefaulttimeout(conn_timeout)
    self.sock = ssl.wrap_socket(self.sock)
    self.file = self.sock.makefile()

    cap = 'CAPABILITY'
    self._simple_command(cap)
    if cap not in self.untagged_responses:
        raise self.error('no CAPABILITY response from server')
    self.capabilities = tuple(self.untagged_responses[cap][-1].upper().split())


def fetch_mails(args, expected_mails):
    global g_M

    if not expected_mails:
        # not expecting any mail, do not check for mails
        return {}, {}

    try:
        mails = {}
        if args.fetch_protocol == 'POP3':
            # Get mails from POP3 mailbox
            g_M = poplib.POP3_SSL(args.fetch_server,
                                  args.fetch_port) if args.fetch_ssl else poplib.POP3(
                                      args.fetch_server, args.fetch_port)
            g_M.user(args.fetch_username)
            g_M.pass_(args.fetch_password)

            num_messages = len(g_M.list()[1])

            for i in range(num_messages):
                index = i + 1
                lines = g_M.retr(index)[1]
                mails[i] = email.message_from_bytes(b"\n".join(lines))

        else:
            # Get mails from IMAP mailbox
            g_M = imaplib.IMAP4_SSL(
                args.fetch_server,  # type: ignore[assignment]
                args.fetch_port) if args.fetch_ssl else imaplib.IMAP4(args.fetch_server,
                                                                      args.fetch_port)

            g_M.login(args.fetch_username, args.fetch_password)  # type: ignore[attr-defined]
            g_M.select('INBOX', readonly=False)  # type: ignore[attr-defined]
            retcode, raw_messages = g_M.search(None, 'NOT', 'DELETED')  # type: ignore[attr-defined]
            messages = raw_messages[0].decode(ENCODING).strip()
            if retcode == 'OK' and messages:
                for num in messages.split():
                    try:
                        _type, data = g_M.fetch(num, '(RFC822)')  # type: ignore[attr-defined]
                        if isinstance(data[0], tuple):
                            mails[num] = email.message_from_bytes(data[0][1])
                    except Exception as e:
                        raise Exception('Failed to fetch mail %s (%s). Available messages: %r' %
                                        (num, parse_exception(e), messages))

        obsolete_mails = {}
        fetched_mails = {}
        # Now filter out the messages for this check
        pattern = re.compile(r'(?:Re: |WG: )?%s ([^\s]+) ([^\s]+)' % args.subject)
        for index, msg in mails.items():
            matches = pattern.match(msg.get('Subject', ''))
            if matches:
                ts = matches.group(1).strip()
                key = matches.group(2).strip()

                # extract received time
                rx = msg.get('Received')
                if rx:
                    parsed = email.utils.parsedate_tz(rx.split(';')[-1])
                    rx_ts = int(time.time()) if parsed is None else email.utils.mktime_tz(parsed)
                else:
                    # use current time as fallback where no Received header could be found
                    rx_ts = int(time.time())

                if "%s-%s" % (ts, key) not in expected_mails:
                    # Delete any "Check_MK-Mail-Loop" messages older than 24 hours, even if
                    # they are not in our list
                    if args.delete_messages and int(time.time()) - rx_ts > 24 * 3600:
                        obsolete_mails[ts + '-' + key] = (index, rx_ts)
                    continue

                fetched_mails[ts + '-' + key] = (index, rx_ts)
        return obsolete_mails, fetched_mails

    except Exception as e:
        if args.debug:
            raise
        raise FetchMailsError('Failed to check for mails: %s' % parse_exception(e))


def send_mail(args, expected_mails):
    now = time.time()
    key = random.randint(1, 1000)

    mail = email.mime.text.MIMEText("")
    mail['From'] = args.mail_from
    mail['To'] = args.mail_to
    mail['Subject'] = '%s %d %d' % (args.subject, now, key)
    mail['Date'] = email.utils.formatdate(localtime=True)

    try:
        S = smtplib.SMTP(args.smtp_server, args.smtp_port)
        if args.smtp_tls:
            S.starttls()
        if args.smtp_username:
            S.login(args.smtp_username, args.smtp_password)
        S.sendmail(args.mail_from, args.mail_to, mail.as_string())
        S.quit()

        add_expected_msg(now, key, expected_mails)

    except Exception as e:
        if args.debug:
            raise
        raise SendMailError('Failed to send mail: %s' % parse_exception(e))


def check_mails(warning, critical, expected_mails, fetched_mails):
    state = 0
    perfdata = []
    output = []

    num_received = 0
    num_pending = 0
    num_lost = 0
    duration = None
    now = time.time()

    # Loop all expected mails and check whether or not they have been received
    for ident, (send_ts, _unused_key) in sorted(expected_mails.items()):
        if ident in fetched_mails:
            recv_ts = fetched_mails[ident][1]

            if duration is None:
                duration = recv_ts - send_ts
            else:
                duration = (duration + (recv_ts - send_ts)) / 2.0  # average

            if critical is not None and duration >= critical:
                state = 2
            elif warning is not None and duration >= warning:
                state = max(state, 1)

            if state:
                output.append(' (warn/crit at %s/%s)' % (warning, critical))

            del expected_mails[ident]  # remove message from expect list
            num_received += 1
            # FIXME: Also remove older mails which have not yet been seen?

        else:
            # drop expecting messages when older than critical threshold,
            # but keep waiting for other mails which have not yet reached it
            if now - send_ts >= critical:
                del expected_mails[ident]
                num_lost += 1
                state = 2
            else:
                num_pending += 1

    if num_received == 1:
        output.insert(0, 'Mail received within %d seconds' % (0 if duration is None else duration))
        perfdata.append(('duration', duration, warning or '', critical or ''))
    elif num_received > 1:
        output.insert(
            0, 'Received %d mails within average of %d seconds' %
            (num_received, (0 if duration is None else duration)))
        perfdata.append(('duration', duration, warning or '', critical or ''))
    else:
        output.insert(0, 'Did not receive any new mail')

    if num_lost:
        output.append('Lost: %d (Did not arrive within %d seconds)' % (num_lost, critical))

    if num_pending:
        output.append('Currently waiting for %d mails' % num_pending)

    return state, ", ".join(output), perfdata


def cleanup_mailbox(args, obsolete_mails, fetched_mails):
    if not g_M:
        return  # do not deal with mailbox when none sent yet

    try:
        # Do not delete all messages in the inbox. Only the ones which were
        # processed before! In the meantime there might be occured new ones.
        for mail_index, _unused_recv_ts in list(fetched_mails.values()) + list(
                obsolete_mails.values()):
            if isinstance(g_M, poplib.POP3):
                response = g_M.dele(mail_index + 1).decode(ENCODING)
                if not response.startswith("+OK"):
                    raise Exception("Response from server: [%s]" % response)
            elif isinstance(g_M, imaplib.IMAP4):
                response = g_M.store(mail_index, '+FLAGS', '\\Deleted')[0]
                if response != 'OK':
                    raise Exception("Response from server: [%s]" % response)

        if isinstance(g_M, imaplib.IMAP4):
            g_M.expunge()

    except Exception as e:
        if args.debug:
            raise
        raise CleanupMailboxError('Failed to delete mail: %s' % parse_exception(e))


def close_mailbox():
    if isinstance(g_M, poplib.POP3):
        g_M.quit()
    elif isinstance(g_M, imaplib.IMAP4):
        g_M.close()
        g_M.logout()


# TODO: Nuke these global variables, just pass them around...
#g_M: Union[None, poplib.POP3, imaplib.IMAP4] = None
g_M = None


def main(sys_args=None):
    args = parse_arguments(sys_args or sys.argv[1:])
    # Enable showing protocol messages of imap for debugging
    if args.fetch_protocol == 'IMAP' and args.debug:
        # Bug in mypy's typeshed.
        imaplib.Debug = 4  # type: ignore[attr-defined]

    try:
        status_path = '%s/check_mail_loop%s.status' % (args.status_dir, (".%s" % args.status_suffix)
                                                       if args.status_suffix else "")

        expected_mails = load_expected_mails(status_path)

        obsolete_mails, fetched_mails = fetch_mails(args, expected_mails)

        send_mail(args, expected_mails)

        state, output, perfdata = check_mails(
            args.warning,
            args.critical,
            expected_mails,
            fetched_mails,
        )

        if args.delete_messages:
            cleanup_mailbox(args, obsolete_mails, fetched_mails)

        save_expected_mails(expected_mails, status_path)

        return state, output, perfdata

    except FetchMailsError as e:
        return 3, str(e), None

    except SendMailError as e:
        return 3, str(e), None

    except CleanupMailboxError as e:
        return 2, str(e), None

    except Exception as e:
        if args.debug:
            raise
        return 2, 'Unhandled exception: %s' % parse_exception(e), None

    finally:
        close_mailbox()


if __name__ == "__main__":
    cmk.utils.password_store.replace_passwords()
    exitcode, info, perf = main()
    output_check_result(exitcode, info, perf)
    sys.exit(exitcode)

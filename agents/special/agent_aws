#!/usr/bin/env python
# -*- encoding: utf-8; py-indent-offset: 4 -*-
# +------------------------------------------------------------------+
# |             ____ _               _        __  __ _  __           |
# |            / ___| |__   ___  ___| | __   |  \/  | |/ /           |
# |           | |   | '_ \ / _ \/ __| |/ /   | |\/| | ' /            |
# |           | |___| | | |  __/ (__|   <    | |  | | . \            |
# |            \____|_| |_|\___|\___|_|\_\___|_|  |_|_|\_\           |
# |                                                                  |
# | Copyright Mathias Kettner 2018             mk@mathias-kettner.de |
# +------------------------------------------------------------------+
#
# This file is part of Check_MK.
# The official homepage is at http://mathias-kettner.de/check_mk.
#
# check_mk is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# tails. You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.
"""
Special agent for monitoring Amazon web services (AWS) with Check_MK.
"""

import abc
import argparse
import datetime
import json
import logging
import sys
import time
import os
from typing import NamedTuple, Any
from pathlib2 import Path
import boto3  # type: ignore
import botocore  # type: ignore
from cmk.utils.paths import tmp_dir
import cmk.utils.password_store

#   .--helpers-------------------------------------------------------------.
#   |                  _          _                                        |
#   |                 | |__   ___| |_ __   ___ _ __ ___                    |
#   |                 | '_ \ / _ \ | '_ \ / _ \ '__/ __|                   |
#   |                 | | | |  __/ | |_) |  __/ |  \__ \                   |
#   |                 |_| |_|\___|_| .__/ \___|_|  |___/                   |
#   |                              |_|                                     |
#   '----------------------------------------------------------------------'


def _datetime_converter(o):
    if isinstance(o, datetime.datetime):
        return o.__str__()


def _chunks(list_, length=100):
    return [list_[i:i + length] for i in xrange(0, len(list_), length)]


#.
#   .--section API---------------------------------------------------------.
#   |                       _   _                  _    ____ ___           |
#   |         ___  ___  ___| |_(_) ___  _ __      / \  |  _ \_ _|          |
#   |        / __|/ _ \/ __| __| |/ _ \| '_ \    / _ \ | |_) | |           |
#   |        \__ \  __/ (__| |_| | (_) | | | |  / ___ \|  __/| |           |
#   |        |___/\___|\___|\__|_|\___/|_| |_| /_/   \_\_|  |___|          |
#   |                                                                      |
#   '----------------------------------------------------------------------'


class AWSSectionError(Exception):
    pass


#   ---result distributor---------------------------------------------------


class ResultDistributor(object):
    """
    Mediator which distributes results from sections
    in order to reduce queries to AWS account.
    """

    def __init__(self):
        self._colleagues = []

    def add(self, colleague):
        self._colleagues.append(colleague)

    def distribute(self, sender, result):
        for colleague in self._colleagues:
            if colleague.name != sender.name:
                colleague.receive(sender, result)


#   ---sections/colleagues--------------------------------------------------

AWSSectionResult = NamedTuple("Result", [
    ("piggyback_hostname", str),
    ("content", Any),
])

AWSStateFilesPath = Path(os.environ['OMD_ROOT']) / tmp_dir / "agents/agent_aws"


class AWSSection(object):
    __metaclass__ = abc.ABCMeta

    def __init__(self, client, distributor=None):
        self._client = client
        self._distributor = ResultDistributor() if distributor is None else distributor
        self._received_results = {}

    @abc.abstractproperty
    def name(self):
        pass

    @abc.abstractproperty
    def interval(self):
        """
        In general the default resolution of AWS metrics is 5 min (300 sec)
        The default resolution of AWS S3 metrics is 1 day (86400 sec)
        We use interval property for cached section.
        """
        pass

    @property
    def period(self):
        return 2 * self.interval

    def run(self):
        if self._client is None:
            msg = "%s: No client initialized" % self.__class__.__name__
            raise AWSSectionError(msg)

        if self.name is None:
            msg = "%s: No name set" % self.__class__.__name__
            raise AWSSectionError(msg)

        try:
            content = self._extract_content_from_raw_result()
        except botocore.exceptions.EndpointConnectionError:
            raise
        except Exception:
            raise

        self._send(content)
        return self._format_content(content)

    @abc.abstractmethod
    def _extract_content_from_raw_result(self):
        """
        Call an API method, eg. 'response = ec2_client.describe_instances()'
        and extract content from raw result.
        Raw results basically consist of two sub results:
        - 'ResponseMetadata'
        - '<KEY>'
        Return raw_result['<KEY>'].
        """
        pass

    @abc.abstractmethod
    def _format_content(self, content):
        """
        Returns a list of named tuples. Each tuple contains
        - piggyback hostname or "", and
        - content
        Use AWSSectionResult.
        """
        pass

    def _send(self, content):
        self._distributor.distribute(self, content)

    def receive(self, sender, content):
        self._received_results.setdefault(sender.name, content)


class AWSSectionGeneric(AWSSection):
    __metaclass__ = abc.ABCMeta


class AWSSectionCloudwatch(AWSSection):
    __metaclass__ = abc.ABCMeta

    def _extract_content_from_raw_result(self):
        end_time = time.time()
        start_time = end_time - self.period
        metrics = self._get_metrics()
        if not metrics:
            return []

        # A single GetMetricData call can include up to 100 MetricDataQuery structures
        # There's no pagination for this operation:
        # self._client.can_paginate('get_metric_data') = False
        content = []
        for chunk in _chunks(metrics):
            if not chunk:
                continue
            response = self._client.get_metric_data(
                MetricDataQueries=chunk,
                StartTime=start_time,
                EndTime=end_time,
            )
            try:
                metrics = response['MetricDataResults']
            except KeyError as e:
                logging.info("%s: KeyError %s; Available are %s", self.name, e, response.keys())
                continue
            content.extend(metrics)
        return content

    @abc.abstractmethod
    def _get_metrics(self):
        """
        Gather specific metrics.
        """
        pass

    def _format_content(self, content):
        content_by_piggyback_hosts = {}
        for row in content:
            content_by_piggyback_hosts.setdefault(row['Label'], []).append(row)
        return [
            AWSSectionResult(piggyback_hostname, rows)
            for piggyback_hostname, rows in content_by_piggyback_hosts.iteritems()
        ]


#.
#   .--costs/usage---------------------------------------------------------.
#   |                      _          __                                   |
#   |         ___ ___  ___| |_ ___   / /   _ ___  __ _  __ _  ___          |
#   |        / __/ _ \/ __| __/ __| / / | | / __|/ _` |/ _` |/ _ \         |
#   |       | (_| (_) \__ \ |_\__ \/ /| |_| \__ \ (_| | (_| |  __/         |
#   |        \___\___/|___/\__|___/_/  \__,_|___/\__,_|\__, |\___|         |
#   |                                                  |___/               |
#   '----------------------------------------------------------------------'

# Interval between 'Start' and 'End' must be a DateInterval. 'End' is exclusive.
# Example:
# 2017-01-01 - 2017-05-01; cost and usage data is retrieved from 2017-01-01 up
# to and including 2017-04-30 but not including 2017-05-01.
# The GetCostAndUsageRequest operation supports only DAILY and MONTHLY granularities.


class CostsAndUsage(AWSSectionGeneric):
    @property
    def name(self):
        return "costs_and_usage"

    @property
    def interval(self):
        return 86400

    def _extract_content_from_raw_result(self):
        fmt = "%Y-%m-%d"
        now = time.time()
        response = self._client.get_cost_and_usage(
            TimePeriod={
                'Start': time.strftime(fmt, time.gmtime(now - self.interval)),
                'End': time.strftime(fmt, time.gmtime(now)),
            },
            Granularity='DAILY',
            Metrics=['UnblendedCost'],
            GroupBy=[{
                'Type': 'DIMENSION',
                'Key': 'LINKED_ACCOUNT'
            }, {
                'Type': 'DIMENSION',
                'Key': 'SERVICE'
            }],
        )
        try:
            return response['ResultsByTime']
        except KeyError as e:
            logging.info("%s: KeyError %s; Available are %s", self.name, e, response.keys())
            return []

    def _format_content(self, content):
        return [AWSSectionResult("", content)]


#.
#   .--security groups-----------------------------------------------------.
#   |                                         _ _                          |
#   |                ___  ___  ___ _   _ _ __(_) |_ _   _                  |
#   |               / __|/ _ \/ __| | | | '__| | __| | | |                 |
#   |               \__ \  __/ (__| |_| | |  | | |_| |_| |                 |
#   |               |___/\___|\___|\__,_|_|  |_|\__|\__, |                 |
#   |                                               |___/                  |
#   |                                                                      |
#   |                    __ _ _ __ ___  _   _ _ __  ___                    |
#   |                   / _` | '__/ _ \| | | | '_ \/ __|                   |
#   |                  | (_| | | | (_) | |_| | |_) \__ \                   |
#   |                   \__, |_|  \___/ \__,_| .__/|___/                   |
#   |                   |___/                |_|                           |
#   '----------------------------------------------------------------------'


class SecurityGroups(AWSSectionGeneric):
    @property
    def name(self):
        return "security_groups"

    @property
    def interval(self):
        return 300

    def _extract_content_from_raw_result(self):
        response = self._client.describe_security_groups()
        try:
            return response['SecurityGroups']
        except KeyError as e:
            logging.info("%s: KeyError %s; Available are %s", self.name, e, response.keys())
            return []

    def _format_content(self, content):
        #return [AWSSectionResult("", content)]
        return


#.
#   .--EC2-----------------------------------------------------------------.
#   |                          _____ ____ ____                             |
#   |                         | ____/ ___|___ \                            |
#   |                         |  _|| |     __) |                           |
#   |                         | |__| |___ / __/                            |
#   |                         |_____\____|_____|                           |
#   |                                                                      |
#   '----------------------------------------------------------------------'


class EC2Summary(AWSSectionGeneric):
    @property
    def name(self):
        return "ec2_summary"

    @property
    def interval(self):
        return 300

    def _extract_content_from_raw_result(self):
        response = self._client.describe_instances()
        try:
            reservations = response['Reservations']
        except KeyError as e:
            logging.info("%s: KeyError %s; Available are %s", self.name, e, response.keys())
            return {}

        for group in self._received_results.get('security_groups'):
            for reservation in reservations:
                if group['OwnerId'] == reservation['OwnerId']:
                    reservation['SecurityGroup'] = group
        return {
            "Reservations": reservations,
            "mapping": self._map_instance_id_to_name(reservations),
        }

    def _map_instance_id_to_name(self, reservations):
        mapping = {}
        for row in reservations:
            for instance in row.get('Instances', []):
                instance_id = instance['InstanceId']
                instance_name = self._extract_instance_name(instance, instance_id)
                mapping.setdefault(instance_id, instance_name)
        return mapping

    def _extract_instance_name(self, instance, instance_id):
        for row in instance.get('Tags', []):
            if row.get('Key') == 'Name':
                return row['Value']
        return instance_id

    def _format_content(self, content):
        return [AWSSectionResult("", content['Reservations'])]


class EC2(AWSSectionCloudwatch):
    @property
    def name(self):
        return "ec2"

    @property
    def interval(self):
        return 300

    def _get_metrics(self):
        metrics = []
        idx = 0
        for instance_id, instance_name in\
            self._received_results.get('ec2_summary', {})\
                                  .get('mapping', {}).iteritems():
            for metric_name, unit in [
                ("CPUCreditUsage", "Count"),
                ("CPUCreditBalance", "Count"),
                ("CPUUtilization", "Percent"),
                ("DiskReadOps", "Count"),
                ("DiskWriteOps", "Count"),
                ("DiskReadBytes", "Bytes"),
                ("DiskWriteBytes", "Bytes"),
                ("NetworkIn", "Bytes"),
                ("NetworkOut", "Bytes"),
                ("StatusCheckFailed_Instance", "Count"),
                ("StatusCheckFailed_System", "Count"),
            ]:
                metrics.append({
                    'Id': "%s_%s" % (metric_name.lower(), idx),
                    'Label': instance_name,
                    'MetricStat': {
                        'Metric': {
                            'Namespace': 'AWS/EC2',
                            'MetricName': metric_name,
                            'Dimensions': [{
                                'Name': "InstanceId",
                                'Value': instance_id,
                            }]
                        },
                        'Period': self.period,
                        'Stat': 'Average',
                        'Unit': unit,
                    },
                })
                idx += 1
        return metrics


#.
#   .--S3------------------------------------------------------------------.
#   |                             ____ _____                               |
#   |                            / ___|___ /                               |
#   |                            \___ \ |_ \                               |
#   |                             ___) |__) |                              |
#   |                            |____/____/                               |
#   |                                                                      |
#   '----------------------------------------------------------------------'


class S3(AWSSectionGeneric):
    def __init__(self, client, distributor=None, buckets=None):
        super(S3, self).__init__(client, distributor=distributor)
        self._buckets = self._determine_buckets(buckets)

    def _determine_buckets(self, buckets):
        if buckets:
            return [{"Name": b} for b in buckets]
        response = self._client.list_buckets()
        try:
            return response['Buckets']
        except KeyError as e:
            logging.info("%s: KeyError %s; Available are %s", self.name, e, response.keys())
            return []

    @property
    def name(self):
        return "s3"

    @property
    def interval(self):
        return 86400

    def _extract_content_from_raw_result(self):
        paginator = self._client.get_paginator('list_objects')
        for bucket in self._buckets:
            bucket_name = bucket['Name']
            response = self._client.get_bucket_location(Bucket=bucket_name)
            try:
                location = response['LocationConstraint']
            except KeyError as e:
                logging.info("%s/%s: KeyError %s; Available are %s", self.name, bucket_name, e,
                             response.keys())
            else:
                bucket['LocationConstraint'] = location

            try:
                response = self._client.get_bucket_tagging(Bucket=bucket_name)
                tagging = response['TagSet']
            except botocore.exceptions.ClientError as e:
                # If there are no tags attached to a bucket we receive a 'ClientError'
                logging.info("%s/%s: No tags set, %s", self.name, bucket_name, e)
            except KeyError as e:
                logging.info("%s/%s: KeyError %s; Available are %s", self.name, bucket_name, e,
                             response.keys())
            else:
                bucket['Tagging'] = tagging

            contents = []
            pages = paginator.paginate(Bucket=bucket_name)
            for page in pages:
                try:
                    objects = page['Contents']
                except KeyError as e:
                    logging.info("%s/%s: KeyError %s; Available are %s", self.name, bucket_name, e,
                                 page.keys())
                else:
                    contents += objects
            bucket['Contents'] = contents
        return self._buckets

    def _format_content(self, content):
        return [AWSSectionResult("", content)]


#.
#   .--ELB-----------------------------------------------------------------.
#   |                          _____ _     ____                            |
#   |                         | ____| |   | __ )                           |
#   |                         |  _| | |   |  _ \                           |
#   |                         | |___| |___| |_) |                          |
#   |                         |_____|_____|____/                           |
#   |                                                                      |
#   '----------------------------------------------------------------------'


class ELBSummary(AWSSectionGeneric):
    @property
    def name(self):
        return "elb_summary"

    @property
    def interval(self):
        return 300

    def _extract_content_from_raw_result(self):
        response = self._client.describe_load_balancers()
        try:
            load_balancers = response['LoadBalancerDescriptions']
        except KeyError, e:
            logging.info("%s: KeyError %s; Available are %s", self.name, e, response.keys())
            return []

        for load_balancer in load_balancers:
            load_balancer_name = load_balancer['LoadBalancerName']
            response = self._client.describe_instance_health(LoadBalancerName=load_balancer_name)
            try:
                states = response['InstanceStates']
            except KeyError, e:
                logging.info("%s/%s: KeyError %s; Available are %s", self.name, load_balancer_name,
                             e, response.keys())
            else:
                load_balancer['InstanceStates'] = states
        return load_balancers

    def _format_content(self, content):
        return [AWSSectionResult("", content)]


class ELBHealth(AWSSectionGeneric):
    @property
    def name(self):
        return "elb_health"

    @property
    def interval(self):
        return 300

    def _extract_content_from_raw_result(self):
        return self._received_results.get('elb_summary', [])

    def _format_content(self, content):
        content_by_piggyback_hosts = {}
        for load_balancer in content:
            try:
                content_by_piggyback_hosts.setdefault(load_balancer['LoadBalancerName'],
                                                      load_balancer['InstanceStates'])
            except KeyError, e:
                logging.info("%s: KeyError %s; Available are %s", self.name, e,
                             load_balancer.keys())
        return [
            AWSSectionResult(piggyback_hostname, rows)
            for piggyback_hostname, rows in content_by_piggyback_hosts.iteritems()
        ]


class ELB(AWSSectionCloudwatch):
    @property
    def name(self):
        return "elb"

    @property
    def interval(self):
        return 300

    def _get_metrics(self):
        load_balancers = []
        for entry in self._received_results.get('elb_summary', []):
            load_balancers.append(entry['LoadBalancerName'])
        metrics = []
        idx = 0
        for load_balancer in load_balancers:
            for metric_name, stat in [
                    # Load balancer metrics
                ("RequestCount", "Sum"),
                ("SurgeQueueLength", "Maximum"),
                ("SpilloverCount", "Sum"),
                ("HTTPCode_ELB_4XX", "Sum"),
                ("HTTPCode_ELB_5XX", "Sum"),
                    # Backend metrics
                ("HealthyHostCount", "Average"),
                ("UnHealthyHostCount", "Average"),
                ("Latency", "Average"),
                ("HTTPCode_Backend_2XX", "Sum"),
                ("HTTPCode_Backend_3XX", "Sum"),
                ("HTTPCode_Backend_4XX", "Sum"),
                ("HTTPCode_Backend_5XX", "Sum"),
                ("BackendConnectionErrors", "Sum"),
            ]:
                metrics.append({
                    'Id': "%s_%s" % (metric_name.lower(), idx),
                    'Label': load_balancer,
                    'MetricStat': {
                        'Metric': {
                            'Namespace': 'AWS/ELB',
                            'MetricName': metric_name,
                            'Dimensions': [{
                                'Name': "LoadBalancerName",
                                'Value': load_balancer,
                            }]
                        },
                        'Period': self.period,
                        'Stat': stat,
                    },
                })
                idx += 1
        return metrics


#.
#   .--EBS-----------------------------------------------------------------.
#   |                          _____ ____ ____                             |
#   |                         | ____| __ ) ___|                            |
#   |                         |  _| |  _ \___ \                            |
#   |                         | |___| |_) |__) |                           |
#   |                         |_____|____/____/                            |
#   |                                                                      |
#   '----------------------------------------------------------------------'

# EBS are attached to EC2 instances. Thus we put the content to related EC2
# instance as piggyback host.


class EBSSummary(AWSSectionGeneric):
    @property
    def name(self):
        return "ebs_summary"

    @property
    def interval(self):
        return 300

    def _extract_content_from_raw_result(self):
        response = self._client.describe_volumes()
        try:
            volumes = {r['VolumeId']: r for r in response['Volumes']}
        except KeyError as e:
            logging.info("%s: KeyError %s; Available are %s", self.name, e, response.keys())
            volumes = {}

        response = self._client.describe_volume_status()
        try:
            volume_states = {r['VolumeId']: r for r in response['VolumeStatuses']}
        except KeyError as e:
            logging.info("%s: KeyError %s; Available are %s", self.name, e, response.keys())
            volume_states = {}

        content = []
        for volume_id in set(volumes.keys()).union(set(volume_states.keys())):
            volume = volumes.get(volume_id, {})
            volume.update(volume_states.get(volume_id, {}))
            content.append(volume)
        return content

    def _format_content(self, content):
        instance_ids = self._received_results.get('ec2_summary', {})\
                                             .get('mapping', {})
        content_by_piggyback_hosts = {}
        for row in content:
            for attachment in row['Attachments']:
                attachment_id = attachment['InstanceId']
                instance_name = instance_ids.get(attachment_id, attachment_id)
                content_by_piggyback_hosts.setdefault(instance_name, [])\
                                          .append(row)
        return [
            AWSSectionResult(piggyback_hostname, rows)
            for piggyback_hostname, rows in content_by_piggyback_hosts.iteritems()
        ]


class EBS(AWSSectionCloudwatch):
    @property
    def name(self):
        return "ebs"

    @property
    def interval(self):
        return 300

    def _get_metrics(self):
        instance_ids = self._received_results.get('ec2_summary', {})\
                                             .get('mapping', {})
        volumes = []
        for row in self._received_results.get('ebs_summary', []):
            vol_id = row['VolumeId']
            vol_type = row['VolumeType']
            for attachment in row['Attachments']:
                attachment_id = attachment['InstanceId']
                instance_name = instance_ids.get(attachment_id, attachment_id)
                volumes.append((instance_name, vol_id, vol_type))
        metrics = []
        idx = 0
        for instance_name, volume_name, volume_type in volumes:
            for metric_name, unit, volume_types in [
                    # Disk IO
                ("VolumeReadOps", "Count", []),
                ("VolumeWriteOps", "Count", []),
                ("VolumeReadBytes", "Bytes", []),
                ("VolumeWriteBytes", "Bytes", []),
                ("VolumeThroughputPercentage", "Percent", ["io1"]),
                ("VolumeConsumedReadWriteOps", "Count", ["io1"]),
                    # Latency
                ("VolumeTotalReadTime", "Seconds", []),
                ("VolumeTotalWriteTime", "Seconds", []),
                    # Disk activity
                ("VolumeQueueLength", "Count", []),
                ("VolumeIdleTime", "Seconds", []),
                ("BurstBalance", "Percent", ["gp2", "st1", "sc1"]),
                    # Status checks
                ("VolumeStatus", None, []),
                ("IOPerformance", None, ["io1"]),
            ]:
                if volume_types and volume_type not in volume_types:
                    continue
                metric = {
                    'Id': "%s_%s" % (metric_name.lower(), idx),
                    'Label': instance_name,
                    'MetricStat': {
                        'Metric': {
                            'Namespace': 'AWS/EBS',
                            'MetricName': metric_name,
                            'Dimensions': [{
                                'Name': "VolumeID",
                                'Value': volume_name,
                            }]
                        },
                        'Period': self.period,
                        'Stat': 'Average',
                    },
                }
                if unit:
                    metric['MetricStat']['Unit'] = unit
                metrics.append(metric)
                idx += 1
        return metrics


#.
#   .--glacier-------------------------------------------------------------.
#   |                         _            _                               |
#   |                    __ _| | __ _  ___(_) ___ _ __                     |
#   |                   / _` | |/ _` |/ __| |/ _ \ '__|                    |
#   |                  | (_| | | (_| | (__| |  __/ |                       |
#   |                   \__, |_|\__,_|\___|_|\___|_|                       |
#   |                   |___/                                              |
#   '----------------------------------------------------------------------'


class Glacier(AWSSectionGeneric):
    @property
    def name(self):
        return "glacier"

    @property
    def interval(self):
        return 300

    def _extract_content_from_raw_result(self):
        response = self._client.list_vaults()
        try:
            vaults = {r['VaultName']: r for r in response['VaultList']}
        except KeyError as e:
            logging.info("%s: KeyError %s; Available are %s", self.name, e, response.keys())
            vaults = {}

        for vault_name, vault in vaults.iteritems():
            response = self._client.list_jobs(vaultName=vault_name)
            try:
                jobs = response['JobList']
            except KeyError as e:
                logging.info("%s/%s: KeyError %s; Available are %s", self.name, vault_name, e,
                             response.keys())
                jobs = []
            vault['Jobs'] = jobs
        return vaults

    def _format_content(self, content):
        return [AWSSectionResult("", content)]


#.
#   .--cloud trail---------------------------------------------------------.
#   |                 _                 _   _             _ _              |
#   |             ___| | ___  _   _  __| | | |_ _ __ __ _(_) |             |
#   |            / __| |/ _ \| | | |/ _` | | __| '__/ _` | | |             |
#   |           | (__| | (_) | |_| | (_| | | |_| | | (_| | | |             |
#   |            \___|_|\___/ \__,_|\__,_|  \__|_|  \__,_|_|_|             |
#   |                                                                      |
#   '----------------------------------------------------------------------'

# AWS eigener Monitoring service


class CloudTrail(AWSSectionGeneric):
    @property
    def name(self):
        return "cloud_trail"

    @property
    def interval(self):
        return 300

    def _extract_content_from_raw_result(self):
        response = self._client.describe_trails()
        try:
            trails = {trail['Name']: trail for trail in response['trailList']}
        except KeyError as e:
            logging.info("%s: KeyError %s; Available are %s", self.name, e, response.keys())
            trails = {}

        for trail_name, trail in trails.iteritems():
            response = self._client.get_trail_status(Name=trail_name)
            trail['Status'] = response
        return trails

    def _format_content(self, content):
        return [AWSSectionResult("", content)]


#.
#   .--sections------------------------------------------------------------.
#   |                               _   _                                  |
#   |                 ___  ___  ___| |_(_) ___  _ __  ___                  |
#   |                / __|/ _ \/ __| __| |/ _ \| '_ \/ __|                 |
#   |                \__ \  __/ (__| |_| | (_) | | | \__ \                 |
#   |                |___/\___|\___|\__|_|\___/|_| |_|___/                 |
#   |                                                                      |
#   '----------------------------------------------------------------------'


class AWSSections(object):
    __metaclass__ = abc.ABCMeta

    def __init__(self, hostname, session, services):
        self._hostname = hostname
        self._session = session
        self._services = services
        self._sections = []
        self._results = {}
        self._exceptions = []

    @abc.abstractmethod
    def init_sections(self, **kwargs):
        pass

    def _init_client(self, client_key):
        try:
            return self._session.client(client_key)
        except (ValueError, botocore.exceptions.ClientError,
                botocore.exceptions.UnknownServiceError) as e:
            # If region name is not valid we get a ValueError
            # but not in all cases, eg.:
            # 1. 'eu-central-' raises a ValueError
            # 2. 'foobar' does not raise a ValueError
            # In the second case we get an exception raised by botocore
            # during we execute an operation, eg. cloudwatch.get_metrics(**kwargs):
            # - botocore.exceptions.EndpointConnectionError
            logging.info(e)
            self._exceptions.append(e)

    def run(self, use_cache=True):
        now = time.time()
        for section in self._sections:
            if use_cache and self._section_cache_is_recent_enough(now, section):
                continue

            try:
                result = section.run()
            except botocore.exceptions.EndpointConnectionError:
                raise
            except Exception as e:
                logging.info(e)
                self._exceptions.append(e)
            else:
                self._results.setdefault((section.name, section.interval), result)

        self._write_exceptions()
        self._write_section_results(now)

    def _section_cache_is_recent_enough(self, now, section):
        state_dir = AWSStateFilesPath / self._hostname
        state_dir.mkdir(parents=True, exist_ok=True)
        state_file = state_dir / Path("%s-%s" % (self._session.region_name, section.name))
        if not state_file.exists():
            logging.info("New state file of section '%s'", section.name)
            state_file.touch()
            return False

        try:
            age = now - state_file.stat().st_mtime
        except OSError as e:
            if e.errno == 2:  # No such file or directory
                logging.info("Cannot calculate age; new state file of section '%s'", section.name)
                state_file.touch()
                return False
            else:
                raise

        if age >= section.interval:
            logging.info("State file of section '%s' is outdated: %s >= %s", section.name, age,
                         section.interval)
            state_file.touch()
            return False
        return True

    def _write_exceptions(self):
        sys.stdout.write("<<<aws_exceptions>>>\n")
        if self._exceptions:
            out = "\n".join([e.message for e in self._exceptions])
        else:
            out = "No exceptions"
        sys.stdout.write("%s: %s\n" % (self.__class__.__name__, out))

    def _write_section_results(self, now):
        if not self._results:
            logging.info("No results or cached data")
            return

        for (section_name, section_interval), result in self._results.iteritems():
            if not result:
                logging.info("No results of %s", section_name)
                continue

            if not isinstance(result, list):
                msg = "Section result must be formatted as a list of 'AWSSectionResult's"
                logging.info(msg)
                continue

            persist_suffix = ""
            if section_interval > 60:
                persist_suffix = ":persist(%s)" % int(now + section_interval + 60)

            if any([r.content for r in result]):
                self._write_section_result(section_name, persist_suffix, result)

    def _write_section_result(self, section_name, persist_suffix, result):
        section_header = "<<<aws_%s%s>>>\n" % (section_name, persist_suffix)
        for row in result:
            write_piggyback_header = row.piggyback_hostname\
                                     and row.piggyback_hostname != self._hostname
            if write_piggyback_header:
                sys.stdout.write("<<<<%s>>>>\n" % row.piggyback_hostname)
            sys.stdout.write(section_header)
            sys.stdout.write("%s\n" % json.dumps(row.content, default=_datetime_converter))
            if write_piggyback_header:
                sys.stdout.write("<<<<>>>>\n")


class AWSSectionsUSEast(AWSSections):
    """
    Some clients like CostExplorer only work with US East region:
    https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/ce-api.html
    """

    def init_sections(self, **kwargs):
        #---clients---------------------------------------------------------
        ce_client = self._init_client('ce')
        s3_client = self._init_client('s3')

        #---sections--------------------------------------------------------
        ce = CostsAndUsage(ce_client)
        s3 = S3(s3_client, buckets=kwargs.get('buckets'))

        #---register sections for execution---------------------------------
        if 'ce' in self._services:
            self._sections.append(ce)

        if 's3' in self._services:
            self._sections.append(s3)


class AWSSectionsGeneric(AWSSections):
    def init_sections(self, **kwargs):
        #---clients---------------------------------------------------------
        ec2_client = self._init_client('ec2')
        elb_client = self._init_client('elb')
        cloudtrail_client = self._init_client('cloudtrail')
        glacier_client = self._init_client('glacier')
        cloudwatch_client = self._init_client('cloudwatch')

        #---distributors----------------------------------------------------
        security_groups_distributor = ResultDistributor()
        ec2_summary_distributor = ResultDistributor()
        elb_summary_distributor = ResultDistributor()
        ebs_summary_distributor = ResultDistributor()

        #---sections with distributors--------------------------------------
        security_groups = SecurityGroups(ec2_client, security_groups_distributor)
        ec2_summary = EC2Summary(ec2_client, ec2_summary_distributor)
        ebs_summary = EBSSummary(ec2_client, ebs_summary_distributor)
        elb_summary = ELBSummary(elb_client, elb_summary_distributor)

        #---sections--------------------------------------------------------
        elb_health = ELBHealth(elb_client)
        cloudtrail = CloudTrail(cloudtrail_client)
        glacier = Glacier(glacier_client)
        ec2 = EC2(cloudwatch_client)
        ebs = EBS(cloudwatch_client)
        elb = ELB(cloudwatch_client)

        #---register sections to distributors-------------------------------
        security_groups_distributor.add(ec2_summary)
        ec2_summary_distributor.add(ec2)
        ec2_summary_distributor.add(ebs_summary)
        ec2_summary_distributor.add(ebs)
        ebs_summary_distributor.add(ebs)
        elb_summary_distributor.add(elb_health)
        elb_summary_distributor.add(elb)

        #---register sections for execution---------------------------------
        # Dependencies: First append sections which distribute their results:
        # -- security_groups
        #    |
        #    |--ec2_summary ('ec2')
        #       |
        #       |-- ec2 ('ec2')
        #       |
        #       |-- ebs_summary ('ec2', 'ebs')
        #       |       |
        #       |       |-- ebs ('ec2', 'ebs')
        #       |
        #       |-- ebs ('ec2')
        #
        # -- elb_summary
        #    |
        #    |-- elb_health
        #    |
        #    |-- elb
        if 'ec2' in self._services:
            self._sections.append(security_groups)
            self._sections.append(ec2_summary)
            self._sections.append(ec2)

        if 'ebs' in self._services:
            self._sections.append(ebs_summary)
            self._sections.append(ebs)

        if 'elb' in self._services:
            self._sections.append(elb_summary)
            self._sections.append(elb_health)
            self._sections.append(elb)

        if 'cloudtrail' in self._services:
            self._sections.append(cloudtrail)

        if 'glacier' in self._services:
            self._sections.append(glacier)


#.
#   .--main----------------------------------------------------------------.
#   |                                       _                              |
#   |                       _ __ ___   __ _(_)_ __                         |
#   |                      | '_ ` _ \ / _` | | '_ \                        |
#   |                      | | | | | | (_| | | | | |                       |
#   |                      |_| |_| |_|\__,_|_|_| |_|                       |
#   |                                                                      |
#   '----------------------------------------------------------------------'

AWSRegions = [
    ("ap-south-1", "Asia Pacific (Mumbai)"),
    ("ap-northeast-3", "Asia Pacific (Osaka-Local)"),
    ("ap-northeast-2", "Asia Pacific (Seoul)"),
    ("ap-southeast-1", "Asia Pacific (Singapore)"),
    ("ap-southeast-2", "Asia Pacific (Sydney)"),
    ("ap-northeast-1", "Asia Pacific (Tokyo)"),
    ("ca-central-1", "Canada (Central)"),
    ("cn-north-1", "China (Beijing)"),
    ("cn-northwest-1", "China (Ningxia)"),
    ("eu-central-1", "EU (Frankfurt)"),
    ("eu-west-1", "EU (Ireland)"),
    ("eu-west-2", "EU (London)"),
    ("eu-west-3", "EU (Paris)"),
    ("eu-north-1", "EU (Stockholm)"),
    ("sa-east-1", "South America (Sao Paulo)"),
    ("us-east-2", "US East (Ohio)"),
    ("us-east-1", "US East (N. Virginia)"),
    ("us-west-1", "US West (N. California)"),
    ("us-west-2", "US West (Oregon)"),
]

AWSServices = [
    ("ce", "Costs and usage"),
    ("ec2", "Elastic Compute Cloud (EC2)"),
    ("ebs", "Elastic Block Storage (EBS)"),
    ("s3", "Simple Storage Service (S3)"),
    #("elb", "Elastic Load Balancing (ELB)"),
    #("cloudtrail", ""),
    #("glacier", ""),
]


def parse_arguments(argv):
    parser = argparse.ArgumentParser(
        description=__doc__, formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument("--debug", action="store_true", help="Raise Python exceptions.")
    parser.add_argument(
        "--aws-access-key-id", required=True, help="The access key for your AWS account.")
    parser.add_argument(
        "--aws-secret-access-key", required=True, help="The secret key for your AWS account.")
    parser.add_argument(
        "--regions",
        nargs='+',
        required=True,
        help="Regions to use:\n%s" % "\n".join(["%-15s %s" % e for e in AWSRegions]))
    parser.add_argument(
        "--services",
        nargs='+',
        required=True,
        help="Services to monitor:\n%s" % "\n".join(["%-15s %s" % e for e in AWSServices]))
    parser.add_argument('--buckets', nargs='+', help="Buckets to monitor")
    parser.add_argument(
        "--no-cache", action="store_true", help="Execute all sections, do not rely on cached data.")
    parser.add_argument("--hostname", required=True)
    return parser.parse_args(argv)


def setup_logging(opt_debug):
    if opt_debug:
        fmt = '%(levelname)s: %(name)s: %(filename)s: %(lineno)s: %(message)s'
        lvl = logging.DEBUG
    else:
        fmt = '%(levelname)s: %(message)s'
        lvl = logging.INFO
    logging.basicConfig(level=lvl, format=fmt)


def create_session(access_key_id, secret_access_key, region):
    return boto3.session.Session(
        aws_access_key_id=access_key_id,
        aws_secret_access_key=secret_access_key,
        region_name=region)


def main(args=None):
    if args is None:
        cmk.utils.password_store.replace_passwords()
        args = sys.argv[1:]

    args = parse_arguments(args)
    setup_logging(args.debug)

    hostname = args.hostname
    access_key_id = args.aws_access_key_id
    secret_access_key = args.aws_secret_access_key
    use_cache = not args.no_cache
    services = args.services

    exceptions = []
    try:
        session = create_session(access_key_id, secret_access_key, "us-east-1")
        aws_sections_us_east = AWSSectionsUSEast(hostname, session, services)
        aws_sections_us_east.init_sections(buckets=args.buckets)
        aws_sections_us_east.run(use_cache=use_cache)
    except Exception as e:
        if args.debug:
            raise
        exceptions.append(e)

    for region in args.regions:
        try:
            session = create_session(access_key_id, secret_access_key, region)
            aws_sections = AWSSectionsGeneric(hostname, session, services)
            aws_sections.init_sections()
            aws_sections.run(use_cache=use_cache)
        except Exception as e:
            if args.debug:
                raise
            exceptions.append(e)

    if exceptions:
        for e in exceptions:
            sys.stderr.write("%s\n" % e)
        return 1
    return 0


if __name__ == "__main__":
    sys.exit(main())

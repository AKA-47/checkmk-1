#!/usr/bin/env python
# -*- encoding: utf-8; py-indent-offset: 4 -*-
# +------------------------------------------------------------------+
# |             ____ _               _        __  __ _  __           |
# |            / ___| |__   ___  ___| | __   |  \/  | |/ /           |
# |           | |   | '_ \ / _ \/ __| |/ /   | |\/| | ' /            |
# |           | |___| | | |  __/ (__|   <    | |  | | . \            |
# |            \____|_| |_|\___|\___|_|\_\___|_|  |_|_|\_\           |
# |                                                                  |
# | Copyright Mathias Kettner 2018             mk@mathias-kettner.de |
# +------------------------------------------------------------------+
#
# This file is part of Check_MK.
# The official homepage is at http://mathias-kettner.de/check_mk.
#
# check_mk is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# tails. You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.
"""
Special agent for monitoring Amazon web services (AWS) with Check_MK.
"""

import abc
import argparse
import datetime
import json
import logging
import sys
import time
import os
from typing import NamedTuple, Any
from pathlib2 import Path
import boto3  # type: ignore
import botocore  # type: ignore
from cmk.utils.paths import tmp_dir
import cmk.utils.password_store

#   .--helpers-------------------------------------------------------------.
#   |                  _          _                                        |
#   |                 | |__   ___| |_ __   ___ _ __ ___                    |
#   |                 | '_ \ / _ \ | '_ \ / _ \ '__/ __|                   |
#   |                 | | | |  __/ | |_) |  __/ |  \__ \                   |
#   |                 |_| |_|\___|_| .__/ \___|_|  |___/                   |
#   |                              |_|                                     |
#   '----------------------------------------------------------------------'


def _datetime_converter(o):
    if isinstance(o, datetime.datetime):
        return o.__str__()


#.
#   .--section API---------------------------------------------------------.
#   |                       _   _                  _    ____ ___           |
#   |         ___  ___  ___| |_(_) ___  _ __      / \  |  _ \_ _|          |
#   |        / __|/ _ \/ __| __| |/ _ \| '_ \    / _ \ | |_) | |           |
#   |        \__ \  __/ (__| |_| | (_) | | | |  / ___ \|  __/| |           |
#   |        |___/\___|\___|\__|_|\___/|_| |_| /_/   \_\_|  |___|          |
#   |                                                                      |
#   '----------------------------------------------------------------------'


class AWSSectionError(Exception):
    pass


#   ---result distributor---------------------------------------------------


class ResultDistributor(object):
    """
    Mediator which distributes results from sections
    in order to reduce queries to AWS account.
    """

    def __init__(self):
        self._colleagues = []

    def add(self, colleague):
        self._colleagues.append(colleague)

    def distribute(self, sender, result):
        for colleague in self._colleagues:
            if colleague.name != sender.name:
                colleague.receive(sender, result)


#   ---sections/colleagues--------------------------------------------------

AWSSectionResult = NamedTuple("Result", [
    ("piggyback_hostname", str),
    ("content", Any),
])

AWSStateFilesPath = Path(os.environ['OMD_ROOT']) / tmp_dir / "agents/agent_aws"


class AWSSection(object):
    __metaclass__ = abc.ABCMeta

    def __init__(self, client, distributor=None):
        self._client = client
        self._distributor = ResultDistributor() if distributor is None else distributor
        self._received_results = {}

    @abc.abstractproperty
    def name(self):
        pass

    @abc.abstractproperty
    def interval(self):
        """
        In general the default resolution of AWS metrics is 5 min (300 sec)
        The default resolution of AWS S3 metrics is 1 day (86400 sec)
        We use interval property for cached section.
        """
        pass

    @property
    def period(self):
        return 2 * self.interval

    def run(self):
        if self._client is None:
            msg = "%s: No client initialized" % self.__class__.__name__
            logging.info(msg)
            raise AWSSectionError(msg)

        if self.name is None:
            msg = "%s: No name set" % self.__class__.__name__
            logging.info(msg)
            raise AWSSectionError(msg)

        try:
            raw_result = self._get_raw_result()
        except botocore.exceptions.EndpointConnectionError as e:
            logging.info(e)
            raise

        content = self._extract_content_from(raw_result)
        self.send(content)
        return self._format_content(content)

    @abc.abstractmethod
    def _get_raw_result(self):
        """
        Returns the raw result which we received from any API method, eg
        response = ec2_client.describe_instances()
        """
        pass

    @abc.abstractmethod
    def _extract_content_from(self, raw_result):
        """
        Raw results basically consist of two sub results:
        - 'ResponseMetadata'
        - '<KEY>'
        Returns raw_result['<KEY>'].
        """
        pass

    @abc.abstractmethod
    def _format_content(self, content):
        """
        Returns a list of named tuples. Each tuple contains
        - piggyback hostname or "", and
        - content
        Use AWSSectionResult.
        """
        pass

    def send(self, content):
        self._distributor.distribute(self, content)

    def receive(self, sender, content):
        self._received_results.setdefault(sender.name, content)


#.
#   .--EC2-----------------------------------------------------------------.
#   |                          _____ ____ ____                             |
#   |                         | ____/ ___|___ \                            |
#   |                         |  _|| |     __) |                           |
#   |                         | |__| |___ / __/                            |
#   |                         |_____\____|_____|                           |
#   |                                                                      |
#   '----------------------------------------------------------------------'


class EC2Summary(AWSSection):
    @property
    def name(self):
        return "ec2_summary"

    @property
    def interval(self):
        return 300

    def _get_raw_result(self):
        return self._client.describe_instances()

    def _extract_content_from(self, raw_result):
        try:
            return raw_result['Reservations']
        except KeyError, e:
            logging.info("%s: KeyError %s; Available are %s", self.name, e, raw_result.keys())
            return

    def _format_content(self, content):
        return [AWSSectionResult("", content)]


class EC2(AWSSection):
    @property
    def name(self):
        return "ec2"

    @property
    def interval(self):
        return 300

    def _get_raw_result(self):
        end_time = time.time()
        start_time = end_time - self.period
        metrics = self._get_metrics()
        if not metrics:
            return {}
        return self._client.get_metric_data(
            MetricDataQueries=metrics,
            StartTime=start_time,
            EndTime=end_time,
        )

    def _get_metrics(self):
        instance_ids = []
        for entry in self._received_results.get('ec2_summary', []):
            for instance in entry.get('Instances', []):
                instance_ids.append(instance['InstanceId'])
        metrics = []
        idx = 0
        for instance_id in instance_ids:
            for metric_name, unit in [
                ("CPUCreditUsage", "Count"),
                ("CPUCreditBalance", "Count"),
                ("CPUUtilization", "Percent"),
                ("DiskReadOps", "Count"),
                ("DiskWriteOps", "Count"),
                ("DiskReadBytes", "Bytes"),
                ("DiskWriteBytes", "Bytes"),
                ("NetworkIn", "Bytes"),
                ("NetworkOut", "Bytes"),
                ("StatusCheckFailed_Instance", "Count"),
                ("StatusCheckFailed_System", "Count"),
            ]:
                metrics.append({
                    'Id': "%s_%s" % (metric_name.lower(), idx),
                    'Label': instance_id,
                    'MetricStat': {
                        'Metric': {
                            'Namespace': 'AWS/EC2',
                            'MetricName': metric_name,
                            'Dimensions': [{
                                'Name': "InstanceId",
                                'Value': instance_id,
                            }]
                        },
                        'Period': self.period,
                        'Stat': 'Average',
                        'Unit': unit,
                    },
                })
                idx += 1
        return metrics

    def _extract_content_from(self, raw_result):
        try:
            return raw_result['MetricDataResults']
        except KeyError, e:
            logging.info("%s: KeyError %s; Available are %s", self.name, e, raw_result.keys())
            return []

    def _format_content(self, content):
        content_by_piggyback_hosts = {}
        for row in content:
            content_by_piggyback_hosts.setdefault(row['Label'], []).append(row)
        return [
            AWSSectionResult(piggyback_hostname, rows)
            for piggyback_hostname, rows in content_by_piggyback_hosts.iteritems()
        ]


#.
#   .--S3------------------------------------------------------------------.
#   |                             ____ _____                               |
#   |                            / ___|___ /                               |
#   |                            \___ \ |_ \                               |
#   |                             ___) |__) |                              |
#   |                            |____/____/                               |
#   |                                                                      |
#   '----------------------------------------------------------------------'


class S3Summary(AWSSection):
    @property
    def name(self):
        return "s3_summary"

    @property
    def interval(self):
        return 86400

    def _get_raw_result(self):
        return self._client.list_buckets()

    def _extract_content_from(self, raw_result):
        try:
            return raw_result['Buckets']
        except KeyError, e:
            logging.info("%s: KeyError %s; Available are %s", self.name, e, raw_result.keys())
            return []

    def _format_content(self, content):
        return [AWSSectionResult("", content)]


class S3(AWSSection):
    """
    The timerange between start time and end time should include midnight. Any
    other time of day will not yield any data.
    """

    @property
    def name(self):
        return "s3"

    @property
    def interval(self):
        return 86400

    def _get_raw_result(self):
        end_time = time.time()
        start_time = end_time - self.period
        metrics = self._get_metrics()
        if not metrics:
            return {}
        return self._client.get_metric_data(
            MetricDataQueries=metrics,
            StartTime=start_time,
            EndTime=end_time,
        )

    def _get_metrics(self):
        bucket_ids = []
        for entry in self._received_results.get('s3_summary', []):
            bucket_ids.append(entry['Name'])
        metrics = []
        idx = 0
        for bucket_id in bucket_ids:
            for metric_name, unit, storage_classes in [
                ("BucketSizeBytes", "Bytes", [
                    "StandardStorage",
                    "StandardIAStorage",
                    "ReducedRedundancyStorage",
                ]),
                ("NumberOfObjects", "Count", ["AllStorageTypes"]),
            ]:
                for storage_class in storage_classes:
                    metrics.append({
                        'Id': "%s_%s_%s" % (metric_name.lower(), storage_class.lower(), idx),
                        'Label': bucket_id,
                        'MetricStat': {
                            'Metric': {
                                'Namespace': 'AWS/S3',
                                'MetricName': metric_name,
                                'Dimensions': [{
                                    'Name': "BucketName",
                                    'Value': bucket_id,
                                }, {
                                    'Name': 'StorageType',
                                    'Value': storage_class,
                                }]
                            },
                            'Period': self.period,
                            'Stat': 'Average',
                            'Unit': unit,
                        },
                    })
                    idx += 1
        return metrics

    def _extract_content_from(self, raw_result):
        try:
            return raw_result['MetricDataResults']
        except KeyError, e:
            logging.info("%s: KeyError %s; Available are %s", self.name, e, raw_result.keys())
            return []

    def _format_content(self, content):
        content_by_piggyback_hosts = {}
        for row in content:
            content_by_piggyback_hosts.setdefault(row['Label'], []).append(row)
        return [
            AWSSectionResult(piggyback_hostname, rows)
            for piggyback_hostname, rows in content_by_piggyback_hosts.iteritems()
        ]


class S3Objects(AWSSection):
    @property
    def name(self):
        return "s3_objects"

    @property
    def interval(self):
        return 86400

    def _get_raw_result(self):
        return [self._client.list_objects(Bucket=bucket_id) for bucket_id in self._get_bucket_ids()]

    def _get_bucket_ids(self):
        bucket_ids = []
        for entry in self._received_results.get('s3_summary', []):
            bucket_ids.append(entry['Name'])
        return bucket_ids

    def _extract_content_from(self, raw_result):
        content = {}
        for row in raw_result:
            try:
                content.setdefault(row['Name'], []).extend(row['Contents'])
            except KeyError, e:
                logging.info("%s: KeyError %s; Available are %s", self.name, e, row.keys())
                continue
        return content

    def _format_content(self, content):
        return [
            AWSSectionResult(piggyback_hostname, rows)
            for piggyback_hostname, rows in content.iteritems()
        ]


#.
#   .--ELB-----------------------------------------------------------------.
#   |                          _____ _     ____                            |
#   |                         | ____| |   | __ )                           |
#   |                         |  _| | |   |  _ \                           |
#   |                         | |___| |___| |_) |                          |
#   |                         |_____|_____|____/                           |
#   |                                                                      |
#   '----------------------------------------------------------------------'


class ELBSummary(AWSSection):
    @property
    def name(self):
        return "elb_summary"

    @property
    def interval(self):
        return 300

    def _get_raw_result(self):
        return self._client.describe_load_balancers()

    def _extract_content_from(self, raw_result):
        try:
            return raw_result['LoadBalancerDescriptions']
        except KeyError, e:
            logging.info("%s: KeyError %s; Available are %s", self.name, e, raw_result.keys())
            return []

    def _format_content(self, content):
        return [AWSSectionResult("", content)]


class ELBHealth(AWSSection):
    @property
    def name(self):
        return "elb_health"

    @property
    def interval(self):
        return 300

    def _get_raw_result(self):
        load_balancers = {}
        for entry in self._received_results.get('elb_summary', []):
            name = entry['LoadBalancerName']
            load_balancers.setdefault(name,
                                      self._client.describe_instance_health(LoadBalancerName=name))
        return load_balancers

    def _extract_content_from(self, raw_result):
        content = {}
        for name, row in raw_result.iteritems():
            try:
                content.setdefault(name, row['InstanceStates'])
            except KeyError, e:
                logging.info("%s: KeyError %s; Available are %s", self.name, e, row.keys())
        return content

    def _format_content(self, content):
        return [
            AWSSectionResult(piggyback_hostname, rows)
            for piggyback_hostname, rows in content.iteritems()
        ]


class ELB(AWSSection):
    @property
    def name(self):
        return "elb"

    @property
    def interval(self):
        return 300

    def _get_raw_result(self):
        end_time = time.time()
        start_time = end_time - self.period
        metrics = self._get_metrics()
        if not metrics:
            return {}
        return self._client.get_metric_data(
            MetricDataQueries=metrics,
            StartTime=start_time,
            EndTime=end_time,
        )

    def _get_metrics(self):
        load_balancers = []
        for entry in self._received_results.get('elb_summary', []):
            load_balancers.append(entry['LoadBalancerName'])
        metrics = []
        idx = 0
        for load_balancer in load_balancers:
            for metric_name, stat in [
                    # Load balancer metrics
                ("RequestCount", "Sum"),
                ("SurgeQueueLength", "Maximum"),
                ("SpilloverCount", "Sum"),
                ("HTTPCode_ELB_4XX", "Sum"),
                ("HTTPCode_ELB_5XX", "Sum"),
                    # Backend metrics
                ("HealthyHostCount", "Average"),
                ("UnHealthyHostCount", "Average"),
                ("Latency", "Average"),
                ("HTTPCode_Backend_2XX", "Sum"),
                ("HTTPCode_Backend_3XX", "Sum"),
                ("HTTPCode_Backend_4XX", "Sum"),
                ("HTTPCode_Backend_5XX", "Sum"),
                ("BackendConnectionErrors", "Sum"),
            ]:
                metrics.append({
                    'Id': "%s_%s" % (metric_name.lower(), idx),
                    'Label': load_balancer,
                    'MetricStat': {
                        'Metric': {
                            'Namespace': 'AWS/ELB',
                            'MetricName': metric_name,
                            'Dimensions': [{
                                'Name': "LoadBalancerName",
                                'Value': load_balancer,
                            }]
                        },
                        'Period': self.period,
                        'Stat': stat,
                    },
                })
                idx += 1
        return metrics

    def _extract_content_from(self, raw_result):
        try:
            return raw_result['MetricDataResults']
        except KeyError, e:
            logging.info("%s: KeyError %s; Available are %s", self.name, e, raw_result.keys())
            return []

    def _format_content(self, content):
        content_by_piggyback_hosts = {}
        for row in content:
            content_by_piggyback_hosts.setdefault(row['Label'], []).append(row)
        return [
            AWSSectionResult(piggyback_hostname, rows)
            for piggyback_hostname, rows in content_by_piggyback_hosts.iteritems()
        ]


#.
#   .--EBS-----------------------------------------------------------------.
#   |                          _____ ____ ____                             |
#   |                         | ____| __ ) ___|                            |
#   |                         |  _| |  _ \___ \                            |
#   |                         | |___| |_) |__) |                           |
#   |                         |_____|____/____/                            |
#   |                                                                      |
#   '----------------------------------------------------------------------'

# EBS are attached to EC2 instances. Thus we put the content to related EC2
# instance as piggyback host.


class EBSSummary(AWSSection):
    @property
    def name(self):
        return "ebs_summary"

    @property
    def interval(self):
        return 300

    def _get_raw_result(self):
        return self._client.describe_volumes()

    def _extract_content_from(self, raw_result):
        try:
            return raw_result['Volumes']
        except KeyError, e:
            logging.info("%s: KeyError %s; Available are %s", self.name, e, raw_result.keys())
            return []

    def _format_content(self, content):
        content_by_piggyback_hosts = {}
        for row in content:
            for attachment in row['Attachments']:
                content_by_piggyback_hosts.setdefault(attachment['InstanceId'], [])\
                                          .append(row)
        return [
            AWSSectionResult(piggyback_hostname, rows)
            for piggyback_hostname, rows in content_by_piggyback_hosts.iteritems()
        ]


class EBSHealth(AWSSection):
    @property
    def name(self):
        return "ebs_health"

    @property
    def interval(self):
        return 300

    def _get_raw_result(self):
        volumes = []
        for entry in self._received_results.get('ebs_summary', []):
            volumes.append(entry['VolumeId'])
        return self._client.describe_volume_status(VolumeIds=volumes)

    def _extract_content_from(self, raw_result):
        content = {}
        for row in raw_result.get('VolumeStatuses', []):
            try:
                content.setdefault(row['VolumeId'], row['VolumeStatus'])
            except KeyError, e:
                logging.info("%s: KeyError %s; Available are %s", self.name, e, row.keys())
        return content

    def _format_content(self, content):
        content_by_piggyback_hosts = {}
        for row in self._received_results.get('ebs_summary', []):
            vol_id = row['VolumeId']
            for attachement in row['Attachments']:
                content_by_piggyback_hosts.setdefault(attachement['InstanceId'], [])\
                                          .append({vol_id: content[vol_id]})
        return [
            AWSSectionResult(piggyback_hostname, rows)
            for piggyback_hostname, rows in content_by_piggyback_hosts.iteritems()
        ]


class EBS(AWSSection):
    @property
    def name(self):
        return "ebs"

    @property
    def interval(self):
        return 300

    def _get_raw_result(self):
        end_time = time.time()
        start_time = end_time - self.period
        metrics = self._get_metrics()
        if not metrics:
            return {}
        return self._client.get_metric_data(
            MetricDataQueries=metrics,
            StartTime=start_time,
            EndTime=end_time,
        )

    def _get_metrics(self):
        volumes = []
        for entry in self._received_results.get('ebs_summary', []):
            volumes.append((entry['VolumeId'], entry['VolumeType']))
        metrics = []
        idx = 0
        for volume_name, volume_type in volumes:
            for metric_name, unit, volume_types in [
                    # Disk IO
                ("VolumeReadOps", "Count", []),
                ("VolumeWriteOps", "Count", []),
                ("VolumeReadBytes", "Bytes", []),
                ("VolumeWriteBytes", "Bytes", []),
                ("VolumeThroughputPercentage", "Percent", ["io1"]),
                ("VolumeConsumedReadWriteOps", "Count", ["io1"]),
                    # Latency
                ("VolumeTotalReadTime", "Seconds", []),
                ("VolumeTotalWriteTime", "Seconds", []),
                    # Disk activity
                ("VolumeQueueLength", "Count", []),
                ("VolumeIdleTime", "Seconds", []),
                ("BurstBalance", "Percent", ["gp2", "st1", "sc1"]),
                    # Status checks
                ("VolumeStatus", None, []),
                ("IOPerformance", None, ["io1"]),
            ]:
                if volume_types and volume_type not in volume_types:
                    continue
                metric = {
                    'Id': "%s_%s" % (metric_name.lower(), idx),
                    'Label': volume_name,
                    'MetricStat': {
                        'Metric': {
                            'Namespace': 'AWS/EBS',
                            'MetricName': metric_name,
                            'Dimensions': [{
                                'Name': "VolumeID",
                                'Value': volume_name,
                            }]
                        },
                        'Period': self.period,
                        'Stat': 'Average',
                    },
                }
                if unit:
                    metric['MetricStat']['Unit'] = unit
                metrics.append(metric)
                idx += 1
        return metrics

    def _extract_content_from(self, raw_result):
        try:
            return raw_result['MetricDataResults']
        except KeyError, e:
            logging.info("%s: KeyError %s; Available are %s", self.name, e, raw_result.keys())
            return []

    def _format_content(self, content):
        #TODO instance ID as piggyback hostname
        return


#.
#   .--glacier-------------------------------------------------------------.
#   |                         _            _                               |
#   |                    __ _| | __ _  ___(_) ___ _ __                     |
#   |                   / _` | |/ _` |/ __| |/ _ \ '__|                    |
#   |                  | (_| | | (_| | (__| |  __/ |                       |
#   |                   \__, |_|\__,_|\___|_|\___|_|                       |
#   |                   |___/                                              |
#   '----------------------------------------------------------------------'


class Glacier(AWSSection):
    @property
    def name(self):
        return "glacier"

    @property
    def interval(self):
        return 300

    def _get_raw_result(self):
        pass

    def _extract_content_from(self, raw_result):
        pass

    def _format_content(self, content):
        pass


#.
#   .--cloud trail---------------------------------------------------------.
#   |                 _                 _   _             _ _              |
#   |             ___| | ___  _   _  __| | | |_ _ __ __ _(_) |             |
#   |            / __| |/ _ \| | | |/ _` | | __| '__/ _` | | |             |
#   |           | (__| | (_) | |_| | (_| | | |_| | | (_| | | |             |
#   |            \___|_|\___/ \__,_|\__,_|  \__|_|  \__,_|_|_|             |
#   |                                                                      |
#   '----------------------------------------------------------------------'


class CloudTrail(AWSSection):
    @property
    def name(self):
        return "cloud_trail"

    @property
    def interval(self):
        return 300

    def _get_raw_result(self):
        pass

    def _extract_content_from(self, raw_result):
        pass

    def _format_content(self, content):
        pass


#.
#   .--sections------------------------------------------------------------.
#   |                               _   _                                  |
#   |                 ___  ___  ___| |_(_) ___  _ __  ___                  |
#   |                / __|/ _ \/ __| __| |/ _ \| '_ \/ __|                 |
#   |                \__ \  __/ (__| |_| | (_) | | | \__ \                 |
#   |                |___/\___|\___|\__|_|\___/|_| |_|___/                 |
#   |                                                                      |
#   '----------------------------------------------------------------------'


class AWSSections(object):
    def __init__(self, session, hostname):
        self._hostname = hostname
        self._session = session
        self._sections = []
        self._results = {}
        self._exceptions = []

        #---clients---------------------------------------------------------
        ec2_client = self._init_client('ec2')
        s3_client = self._init_client('s3')
        elb_client = self._init_client('elb')
        cloudwatch_client = self._init_client('cloudwatch')

        #---distributors----------------------------------------------------
        ec2_summary_distributor = ResultDistributor()
        s3_summary_distributor = ResultDistributor()
        elb_summary_distributor = ResultDistributor()
        ebs_summary_distributor = ResultDistributor()

        #---sections with distributors--------------------------------------
        ec2_summary = EC2Summary(ec2_client, ec2_summary_distributor)
        s3_summary = S3Summary(s3_client, s3_summary_distributor)
        elb_summary = ELBSummary(elb_client, elb_summary_distributor)
        ebs_summary = EBSSummary(ec2_client, ebs_summary_distributor)

        #---sections--------------------------------------------------------
        ec2 = EC2(cloudwatch_client)
        s3_objects = S3Objects(s3_client)
        s3 = S3(cloudwatch_client)
        elb_health = ELBHealth(elb_client)
        elb = ELB(cloudwatch_client)
        ebs_health = EBSHealth(ec2_client)
        ebs = EBS(cloudwatch_client)

        #---register sections to distributors-------------------------------
        ec2_summary_distributor.add(ec2)
        s3_summary_distributor.add(s3_objects)
        s3_summary_distributor.add(s3)
        elb_summary_distributor.add(elb_health)
        elb_summary_distributor.add(elb)
        ebs_summary_distributor.add(ebs_health)
        ebs_summary_distributor.add(ebs)

        #---register sections with distributors for execution---------------
        self._sections.append(ec2_summary)
        self._sections.append(s3_summary)
        self._sections.append(elb_summary)
        self._sections.append(ebs_summary)

        #---register sections for execution---------------------------------
        self._sections.append(ec2)
        self._sections.append(s3_objects)
        self._sections.append(s3)
        self._sections.append(elb_health)
        self._sections.append(elb)
        self._sections.append(ebs_health)
        self._sections.append(ebs)

    def _init_client(self, client_key):
        try:
            return self._session.client(client_key)
        except (ValueError, botocore.exceptions.ClientError,
                botocore.exceptions.UnknownServiceError) as e:
            # If region name is not valid we get a ValueError
            # but not in all cases, eg.:
            # 1. 'eu-central-' raises a ValueError
            # 2. 'foobar' does not raise a ValueError
            # In the second case we get an exception raised by botocore
            # during we execute an operation, eg. cloudwatch.get_metrics(**kwargs):
            # - botocore.exceptions.EndpointConnectionError
            logging.info(e)
            self._exceptions.append(e)

    def run(self, use_cache=True):
        now = time.time()
        for section in self._sections:
            if use_cache and self._section_cache_is_recent_enough(now, section):
                continue

            try:
                result = section.run()
            except Exception as e:
                logging.info(e)
                self._exceptions.append(e)
            else:
                self._results.setdefault((section.name, section.interval), result)

        if not self._results:
            logging.info("No results or cached data")
            return

        self._write_exceptions()
        self._write_section_results(now)

    def _section_cache_is_recent_enough(self, now, section):
        state_dir = AWSStateFilesPath / self._hostname
        state_dir.mkdir(parents=True, exist_ok=True)
        state_file = state_dir / Path("%s-%s" % (self._session.region_name, section.name))
        if not state_file.exists():
            logging.info("New state file of section '%s'", section.name)
            state_file.touch()
            return False

        try:
            age = now - state_file.stat().st_mtime
        except OSError as e:
            if e.errno == 2:  # No such file or directory
                logging.info("Cannot calculate age; new state file of section '%s'", section.name)
                state_file.touch()
                return False
            else:
                raise

        if age >= section.interval:
            logging.info("State file of section '%s' is outdated: %s >= %s", section.name, age,
                         section.interval)
            state_file.touch()
            return False
        return True

    def _write_exceptions(self):
        sys.stdout.write("<<<aws_exceptions>>>\n")
        if self._exceptions:
            out = "\n".join([e.message for e in self._exceptions])
        else:
            out = "No exceptions"
        sys.stdout.write("%s\n" % out)

    def _write_section_results(self, now):
        for (section_name, section_interval), result in self._results.iteritems():
            if not result:
                logging.info("No results of %s", section_name)
                continue

            if not isinstance(result, list):
                msg = "Section result must be formatted as a list of 'AWSSectionResult's"
                logging.info(msg)
                raise AWSSectionError(msg)

            self._write_section_result(section_name, int(now + section_interval + 60), result)

    def _write_section_result(self, section_name, until, result):
        section_header = "<<<aws_%s:persist(%s)>>>\n" % (section_name, until)
        for row in result:
            write_piggyback_header = row.piggyback_hostname\
                                     and row.piggyback_hostname != self._hostname
            if write_piggyback_header:
                sys.stdout.write("<<<<%s>>>>\n" % row.piggyback_hostname)
            sys.stdout.write(section_header)
            sys.stdout.write("%s\n" % json.dumps(row.content, default=_datetime_converter))
            if write_piggyback_header:
                sys.stdout.write("<<<<>>>>\n")


#.
#   .--main----------------------------------------------------------------.
#   |                                       _                              |
#   |                       _ __ ___   __ _(_)_ __                         |
#   |                      | '_ ` _ \ / _` | | '_ \                        |
#   |                      | | | | | | (_| | | | | |                       |
#   |                      |_| |_| |_|\__,_|_|_| |_|                       |
#   |                                                                      |
#   '----------------------------------------------------------------------'


def parse_arguments(argv):
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("--debug", action="store_true", help="Raise Python exceptions.")
    parser.add_argument(
        "--aws-access-key-id", required=True, help="The access key for your AWS account.")
    parser.add_argument(
        "--aws-secret-access-key", required=True, help="The secret key for your AWS account.")
    parser.add_argument("--region", required=True, help="The region to use.")
    parser.add_argument(
        "--no-cache", action="store_true", help="Execute all sections, do not rely on cached data.")
    parser.add_argument("hostname")
    return parser.parse_args(argv)


def setup_logging(opt_debug):
    if opt_debug:
        fmt = '%(levelname)s: %(name)s: %(filename)s: %(lineno)s: %(message)s'
        lvl = logging.DEBUG
    else:
        fmt = '%(levelname)s: %(message)s'
        lvl = logging.INFO
    logging.basicConfig(level=lvl, format=fmt)


def main(args=None):
    if args is None:
        cmk.utils.password_store.replace_passwords()
        args = sys.argv[1:]

    args = parse_arguments(args)
    setup_logging(args.debug)

    s = boto3.session.Session(
        aws_access_key_id=args.aws_access_key_id,
        aws_secret_access_key=args.aws_secret_access_key,
        region_name=args.region)

    try:
        aws_sections = AWSSections(s, args.hostname)
        aws_sections.run(use_cache=not args.no_cache)
    except Exception as e:
        if args.debug:
            raise
        sys.stderr.write("%s\n" % e)
        return 1
    return 0


if __name__ == "__main__":
    sys.exit(main())

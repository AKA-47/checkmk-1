#!/usr/bin/env python
# -*- encoding: utf-8; py-indent-offset: 4 -*-
# +------------------------------------------------------------------+
# |             ____ _               _        __  __ _  __           |
# |            / ___| |__   ___  ___| | __   |  \/  | |/ /           |
# |           | |   | '_ \ / _ \/ __| |/ /   | |\/| | ' /            |
# |           | |___| | | |  __/ (__|   <    | |  | | . \            |
# |            \____|_| |_|\___|\___|_|\_\___|_|  |_|_|\_\           |
# |                                                                  |
# | Copyright Mathias Kettner 2018             mk@mathias-kettner.de |
# +------------------------------------------------------------------+
#
# This file is part of Check_MK.
# The official homepage is at http://mathias-kettner.de/check_mk.
#
# check_mk is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# tails. You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.
"""
Special agent for monitoring Amazon web services (AWS) with Check_MK.
"""

import sys
import argparse
import boto3
import abc
import botocore
import datetime
import json
import logging
import time

import cmk.password_store

#   .--helpers-------------------------------------------------------------.
#   |                  _          _                                        |
#   |                 | |__   ___| |_ __   ___ _ __ ___                    |
#   |                 | '_ \ / _ \ | '_ \ / _ \ '__/ __|                   |
#   |                 | | | |  __/ | |_) |  __/ |  \__ \                   |
#   |                 |_| |_|\___|_| .__/ \___|_|  |___/                   |
#   |                              |_|                                     |
#   '----------------------------------------------------------------------'


def _datetime_converter(o):
    if isinstance(o, datetime.datetime):
        return o.__str__()


#.
#   .--sections------------------------------------------------------------.
#   |                               _   _                                  |
#   |                 ___  ___  ___| |_(_) ___  _ __  ___                  |
#   |                / __|/ _ \/ __| __| |/ _ \| '_ \/ __|                 |
#   |                \__ \  __/ (__| |_| | (_) | | | \__ \                 |
#   |                |___/\___|\___|\__|_|\___/|_| |_|___/                 |
#   |                                                                      |
#   '----------------------------------------------------------------------'


class AWSSectionError(Exception):
    pass


#   ---section interface----------------------------------------------------


class AWSSection(object):
    __metaclass__ = abc.ABCMeta

    def __init__(self, client):
        self._client = client

    @abc.abstractmethod
    def name(self):
        pass

    def run(self, **kwargs):
        if self._client is None:
            msg = "%s: No client initialized" % self.__class__.__name__
            logging.info(msg)
            raise AWSSectionError(msg)

        name = self.name()
        if name is None:
            msg = "%s: No name set" % self.__class__.__name__
            logging.info(msg)
            raise AWSSectionError(msg)

        try:
            raw_result = self._get_raw_result(**kwargs)
        except botocore.exceptions.EndpointConnectionError as e:
            logging.info(e)
            raise

        content = self._extract_content_from(raw_result)
        if content:
            sys.stdout.write("<<<aws_%s>>>\n" % name)
            sys.stdout.write("%s\n" % json.dumps(content, default=_datetime_converter))
        return content

    @abc.abstractmethod
    def _get_raw_result(self, **kwargs):
        pass

    @abc.abstractmethod
    def _extract_content_from(self, raw_result):
        pass


#   ---sections-------------------------------------------------------------


class EC2InstancesSummary(AWSSection):
    def name(self):
        return "ec2_instances_summary"

    def _get_raw_result(self, **kwargs):
        return self._client.describe_instances()

    def _extract_content_from(self, raw_result):
        try:
            return raw_result['Reservations']
        except KeyError, e:
            logging.info(e)
            return


class EC2Instance(AWSSection):
    # Metrics for burstable performance instances:
    # CPUCreditUsage
    # CPUCreditBalance
    # CPUSurplusCreditBalance
    # CPUSurplusCreditsCharged

    # Instance metrics:
    # CPUUtilization
    # DiskReadOps
    # DiskWriteOps
    # DiskReadBytes
    # DiskWriteBytes
    # NetworkIn
    # NetworkOut
    # NetworkPacketsIn
    # NetworkPacketsOut

    # StatusCheckFailed
    # StatusCheckFailed_Instance
    # StatusCheckFailed_System
    def name(self):
        return "ec2_instance"

    def _get_raw_result(self, **kwargs):
        pass

    def _extract_content_from(self, raw_result):
        pass


class CostAndUsage(AWSSection):
    def name(self):
        return "cost_and_usage"

    def _get_raw_result(self, **kwargs):
        # Note:
        # If you return the UsageQuantity metric, the service aggregates all usage
        # numbers without taking into account the units. For example, if you aggregate
        # usageQuantity across all of EC2, the results aren't meaningful because EC2
        # compute hours and data transfer are measured in different units (for example,
        # hours vs. GB). To get more meaningful UsageQuantity metrics, filter by
        # UsageType or UsageTypeGroups.

        #TODO

        now = time.time()
        start = time.strftime("%Y-%m-%d", time.localtime(now))
        # End time is exclusive
        end = time.strftime("%Y-%m-%d", time.localtime(now + 86400))
        return self._client.get_cost_and_usage(
            TimePeriod={
                'Start': start,
                'End': end,
            },
            Granularity='DAILY',
            Metrics=[
                'UsageQuantity',
            ],
        )

    def _extract_content_from(self, raw_result):
        try:
            return raw_result['ResultsByTime']
        except KeyError, e:
            logging.info(e)
            return


#   ---sections handler-----------------------------------------------------


class AWSSections(object):
    def __init__(self, session):
        self._session = session
        self._sections = []
        self._exceptions = []

        #---clients---------------------------------------------------------
        client_cloudwatch = self._init_client('cloudwatch')
        client_ec2 = self._init_client('ec2')
        client_ce = self._init_client('ce')
        #client_s3 = self._init_client('s3')
        #client_elb = self._init_client('elb')
        #client_ebs = self._init_client('ebs')

        #---sections--------------------------------------------------------
        self._sections.append(EC2InstancesSummary(client_ec2))
        self._sections.append(EC2Instance(client_cloudwatch))
        self._sections.append(CostAndUsage(client_ce))

    def _init_client(self, client_key):
        try:
            return self._session.client(client_key)
        except (ValueError, botocore.exceptions.ClientError,
                botocore.exceptions.UnknownServiceError) as e:
            # If region name is not valid we get a ValueError
            # but not in all cases, eg.:
            # 1. 'eu-central-' raises a ValueError
            # 2. 'foobar' does not raise a ValueError
            # In the second case we get an exception raised by botocore
            # during we execute an operation, eg. cloudwatch.get_metrics(**kwargs):
            # - botocore.exceptions.EndpointConnectionError
            logging.info(e)
            self._exceptions.append(e)

    def run(self):
        for section in self._sections:
            try:
                section.run()
            except Exception as e:
                logging.info(e)
                self._exceptions.append(e)

        sys.stdout.write("<<<aws_exceptions>>>\n")
        if self._exceptions:
            for e in self._exceptions:
                sys.stdout.write("%s\n" % e.message)
        else:
            sys.stdout.write("No exceptions\n")


#.
#   .--main----------------------------------------------------------------.
#   |                                       _                              |
#   |                       _ __ ___   __ _(_)_ __                         |
#   |                      | '_ ` _ \ / _` | | '_ \                        |
#   |                      | | | | | | (_| | | | | |                       |
#   |                      |_| |_| |_|\__,_|_|_| |_|                       |
#   |                                                                      |
#   '----------------------------------------------------------------------'


def parse_arguments(argv):
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("--debug", action="store_true", help="Raise Python exceptions.")
    parser.add_argument(
        "--aws-access-key-id", required=True, help="The access key for your AWS account.")
    parser.add_argument(
        "--aws-secret-access-key", required=True, help="The secret key for your AWS account.")
    parser.add_argument("--region", required=True, help="The region to use.")
    return parser.parse_args(argv)


def setup_logging(opt_debug):
    if opt_debug:
        fmt = '%(levelname)s: %(name)s: %(filename)s: %(lineno)s: %(message)s'
        lvl = logging.DEBUG
    else:
        fmt = '%(levelname)s: %(message)s'
        lvl = logging.INFO
    logging.basicConfig(level=lvl, format=fmt)


def main(args=None):
    if args is None:
        cmk.password_store.replace_passwords()
        args = sys.argv[1:]

    args = parse_arguments(args)
    setup_logging(args.debug)

    s = boto3.session.Session(
        aws_access_key_id=args.aws_access_key_id,
        aws_secret_access_key=args.aws_secret_access_key,
        region_name=args.region)

    try:
        aws_sections = AWSSections(s)
        aws_sections.run()
    except Exception as e:
        if args.debug:
            raise
        sys.stderr.write("%s\n" % e)
        return 1
    return 0


if __name__ == "__main__":
    sys.exit(main())

#!/usr/bin/env python
# -*- encoding: utf-8; py-indent-offset: 4 -*-
# +------------------------------------------------------------------+
# |             ____ _               _        __  __ _  __           |
# |            / ___| |__   ___  ___| | __   |  \/  | |/ /           |
# |           | |   | '_ \ / _ \/ __| |/ /   | |\/| | ' /            |
# |           | |___| | | |  __/ (__|   <    | |  | | . \            |
# |            \____|_| |_|\___|\___|_|\_\___|_|  |_|_|\_\           |
# |                                                                  |
# | Copyright Mathias Kettner 2018             mk@mathias-kettner.de |
# +------------------------------------------------------------------+
#
# This file is part of Check_MK.
# The official homepage is at http://mathias-kettner.de/check_mk.
#
# check_mk is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# tails. You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.
"""
Special agent for monitoring Amazon web services (AWS) with Check_MK.
"""

import abc
import argparse
import datetime
import json
import logging
import sys
import time
from typing import NamedTuple, Any

import boto3
import botocore

import cmk.password_store

#   .--helpers-------------------------------------------------------------.
#   |                  _          _                                        |
#   |                 | |__   ___| |_ __   ___ _ __ ___                    |
#   |                 | '_ \ / _ \ | '_ \ / _ \ '__/ __|                   |
#   |                 | | | |  __/ | |_) |  __/ |  \__ \                   |
#   |                 |_| |_|\___|_| .__/ \___|_|  |___/                   |
#   |                              |_|                                     |
#   '----------------------------------------------------------------------'


def _datetime_converter(o):
    if isinstance(o, datetime.datetime):
        return o.__str__()


#.
#   .--sections------------------------------------------------------------.
#   |                               _   _                                  |
#   |                 ___  ___  ___| |_(_) ___  _ __  ___                  |
#   |                / __|/ _ \/ __| __| |/ _ \| '_ \/ __|                 |
#   |                \__ \  __/ (__| |_| | (_) | | | \__ \                 |
#   |                |___/\___|\___|\__|_|\___/|_| |_|___/                 |
#   |                                                                      |
#   '----------------------------------------------------------------------'


class AWSSectionError(Exception):
    pass


#   ---result distributor---------------------------------------------------


class ResultDistributor(object):
    """
    Mediator which distributes results from sections
    in order to reduce queries to AWS account.
    """

    def __init__(self):
        self._colleagues = []

    def add(self, colleague):
        self._colleagues.append(colleague)

    def distribute(self, sender, result):
        for colleague in self._colleagues:
            if colleague.name != sender.name:
                colleague.receive(sender, result)


#   ---sections/colleagues--------------------------------------------------

AWSSectionResult = NamedTuple("Result", [
    ("piggyback_hostname", str),
    ("content", Any),
])


class AWSSection(object):
    __metaclass__ = abc.ABCMeta

    def __init__(self, client, distributor=None):
        self._client = client
        self._distributor = ResultDistributor() if distributor is None else distributor
        self._received_results = {}

    @abc.abstractproperty
    def name(self):
        pass

    @abc.abstractproperty
    def interval(self):
        """
        In general the default resolution of AWS metrics is 5 min (300 sec)
        The default resolution of AWS S3 metrics is 1 day (86400 sec)
        We use interval property for cached section.
        """
        pass

    def run(self):
        if self._client is None:
            msg = "%s: No client initialized" % self.__class__.__name__
            logging.info(msg)
            raise AWSSectionError(msg)

        if self.name is None:
            msg = "%s: No name set" % self.__class__.__name__
            logging.info(msg)
            raise AWSSectionError(msg)

        try:
            raw_result = self._get_raw_result()
        except botocore.exceptions.EndpointConnectionError as e:
            logging.info(e)
            raise

        content = self._extract_content_from(raw_result)
        self.send(content)
        return self._format_content(content)

    @abc.abstractmethod
    def _get_raw_result(self):
        """
        Returns the raw result which we received from any API method, eg
        response = ec2_client.describe_instances()
        """
        pass

    @abc.abstractmethod
    def _extract_content_from(self, raw_result):
        """
        Raw results basically consist of two sub results:
        - 'ResponseMetadata'
        - '<KEY>'
        Returns raw_result['<KEY>'].
        """
        pass

    @abc.abstractmethod
    def _format_content(self, content):
        """
        Returns a list of named tuples. Each tuple contains
        - piggyback hostname or "", and
        - content
        Use AWSSectionResult.
        """
        pass

    def send(self, content):
        self._distributor.distribute(self, content)

    def receive(self, sender, content):
        self._received_results.setdefault(sender.name, content)


class EC2Summary(AWSSection):
    @property
    def name(self):
        return "ec2_summary"

    @property
    def interval(self):
        return 300

    def _get_raw_result(self):
        return self._client.describe_instances()

    def _extract_content_from(self, raw_result):
        try:
            return raw_result['Reservations']
        except KeyError, e:
            logging.info(e)
            return

    def _format_content(self, content):
        return [AWSSectionResult("", content)]


class EC2(AWSSection):
    @property
    def name(self):
        return "ec2"

    @property
    def interval(self):
        return 300

    def _get_raw_result(self):
        pass

    def _extract_content_from(self, raw_result):
        pass

    def _format_content(self, content):
        pass


#   ---sections handler-----------------------------------------------------


class AWSSections(object):
    def __init__(self, session):
        self._session = session
        self._sections = []
        self._results = {}
        self._exceptions = []

        #---clients---------------------------------------------------------
        ec2_client = self._init_client('ec2')
        cloudwatch_client = self._init_client('cloudwatch')

        #---distributors----------------------------------------------------
        ec2_summary_distributor = ResultDistributor()

        #---sections--------------------------------------------------------
        ec2_summary = EC2Summary(ec2_client, ec2_summary_distributor)
        ec2 = EC2(cloudwatch_client)

        #---distributors registry-------------------------------------------
        ec2_summary_distributor.add(ec2)

        #---section registry------------------------------------------------
        self._sections.append(ec2_summary)
        self._sections.append(ec2)

    def _init_client(self, client_key):
        try:
            return self._session.client(client_key)
        except (ValueError, botocore.exceptions.ClientError,
                botocore.exceptions.UnknownServiceError) as e:
            # If region name is not valid we get a ValueError
            # but not in all cases, eg.:
            # 1. 'eu-central-' raises a ValueError
            # 2. 'foobar' does not raise a ValueError
            # In the second case we get an exception raised by botocore
            # during we execute an operation, eg. cloudwatch.get_metrics(**kwargs):
            # - botocore.exceptions.EndpointConnectionError
            logging.info(e)
            self._exceptions.append(e)

    def run(self):
        for section in self._sections:
            try:
                result = section.run()
            except Exception as e:
                logging.info(e)
                self._exceptions.append(e)
            else:
                self._results.setdefault((section.name, section.interval), result)

        if not self._results:
            logging.info("No results")
            return

        self._write_results()

    def _write_results(self):
        sys.stdout.write("<<<aws_exceptions>>>\n")
        if self._exceptions:
            for e in self._exceptions:
                sys.stdout.write("%s\n" % e.message)
        else:
            sys.stdout.write("No exceptions\n")

        now = int(time.time())
        for (section_name, section_interval), result in self._results.iteritems():
            if not result:
                msg = "No results of %s" % section_name
                logging.info(msg)
                continue
            if not isinstance(result, list):
                msg = "Section result must be formatted as a list of 'AWSSectionResult's"
                logging.info(msg)
                raise AWSSectionError(msg)

            section_header = "<<<aws_%s:cached(%s,%s)>>>\n" % (section_name, now, section_interval)
            for row in result:
                if row.piggyback_hostname:
                    sys.stdout.write(section_header)
                sys.stdout.write("<<<aws_%s>>>\n" % section_name)
                sys.stdout.write("%s\n" % json.dumps(row.content, default=_datetime_converter))
                if row.piggyback_hostname:
                    sys.stdout.write("<<<<>>>>\n")


#.
#   .--main----------------------------------------------------------------.
#   |                                       _                              |
#   |                       _ __ ___   __ _(_)_ __                         |
#   |                      | '_ ` _ \ / _` | | '_ \                        |
#   |                      | | | | | | (_| | | | | |                       |
#   |                      |_| |_| |_|\__,_|_|_| |_|                       |
#   |                                                                      |
#   '----------------------------------------------------------------------'


def parse_arguments(argv):
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("--debug", action="store_true", help="Raise Python exceptions.")
    parser.add_argument(
        "--aws-access-key-id", required=True, help="The access key for your AWS account.")
    parser.add_argument(
        "--aws-secret-access-key", required=True, help="The secret key for your AWS account.")
    parser.add_argument("--region", required=True, help="The region to use.")
    return parser.parse_args(argv)


def setup_logging(opt_debug):
    if opt_debug:
        fmt = '%(levelname)s: %(name)s: %(filename)s: %(lineno)s: %(message)s'
        lvl = logging.DEBUG
    else:
        fmt = '%(levelname)s: %(message)s'
        lvl = logging.INFO
    logging.basicConfig(level=lvl, format=fmt)


def main(args=None):
    if args is None:
        cmk.password_store.replace_passwords()
        args = sys.argv[1:]

    args = parse_arguments(args)
    setup_logging(args.debug)

    s = boto3.session.Session(
        aws_access_key_id=args.aws_access_key_id,
        aws_secret_access_key=args.aws_secret_access_key,
        region_name=args.region)

    try:
        aws_sections = AWSSections(s)
        aws_sections.run()
    except Exception as e:
        if args.debug:
            raise
        sys.stderr.write("%s\n" % e)
        return 1
    return 0


if __name__ == "__main__":
    sys.exit(main())

#!/usr/bin/python
# -*- encoding: utf-8; py-indent-offset: 4 -*-
# +------------------------------------------------------------------+
# |             ____ _               _        __  __ _  __           |
# |            / ___| |__   ___  ___| | __   |  \/  | |/ /           |
# |           | |   | '_ \ / _ \/ __| |/ /   | |\/| | ' /            |
# |           | |___| | | |  __/ (__|   <    | |  | | . \            |
# |            \____|_| |_|\___|\___|_|\_\___|_|  |_|_|\_\           |
# |                                                                  |
# | Copyright Mathias Kettner 2018             mk@mathias-kettner.de |
# +------------------------------------------------------------------+
#
# This file is part of Check_MK.
# The official homepage is at http://mathias-kettner.de/check_mk.
#
# check_mk is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# tails. You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.
import json
import re


def _docker_get_bytes(string):
    '''get number of bytes from string

    e.g.
    "123GB (42%)" -> 123000000000
    "0 B"         -> 0
    "2B"          -> 2
    "23 kB"       -> 23000
    '''
    # remove percent
    string = string.split('(')[0].strip()
    tmp = re.split('([a-zA-Z]+)', string)
    value_string = tmp[0].strip()
    unit_string = tmp[1].strip() if len(tmp) > 1 else 'B'
    try:
        factor = {
            'TB': 10**12,
            'GB': 10**9,
            'MB': 10**6,
            'KB': 10**3,
            'kB': 10**3,
            'B' : 1,
            ''  : 1,
        }[unit_string]
        return int(float(value_string) * factor)
    except (ValueError, TypeError):
        return None


def parse_docker_node_info(info):
    '''parse output of "docker info"'''
    try:
        # parse legacy json output (verisons 1.5.0 - 1.5.0p6)
        return json.loads(" ".join(info[0]))
    except ValueError:
        pass

    parsed = {}
    prefix = ""
    for row in info:
        if not row:
            continue
        # remove '|', it was protecting leading whitespace
        row0 = row[0][1:]
        if not row0:
            continue
        # ignore misssing keys / pad lines that are not of "key: value" type
        if len(row) == 1:
            row.append('')
        key = row0.strip()
        value = ':'.join(row[1:]).strip()
        # indented keys are prefixed by the last not indented key
        if len(row0) - len(key) == 0:
            parsed[key] = value
            prefix = key
        else:
            parsed[prefix + key] = value

    ## some modifications to match json output:
    for key in ("Images", "Containers", "ContainersRunning",
                "ContainersStopped", "ContainersPaused"):
        try:
            parsed[key] = int(parsed[key])
        except (KeyError, ValueError):
            pass
    # reconstruct labels (they where not in "k: v" format)
    parsed["Labels"] = []
    for k in parsed.keys():  # pylint: disable=consider-iterating-dictionary
        if k.startswith("Labels") and k != "Labels":
            parsed["Labels"].append(k[6:] + parsed.pop(k))
    # reconstruct swarm info:
    swarm = {"LocalNodeState": parsed["Swarm"]}
    if "SwarmNodeID" in parsed:
        swarm["NodeID"] = parsed["SwarmNodeID"]
    if "SwarmManagers" in parsed:
        swarm["RemoteManagers"] = parsed["SwarmManagers"]
    parsed["Swarm"] = swarm
    parsed["ServerVersion"] = parsed["Server Version"]
    parsed["IndexServerAddress"] = parsed["Registry"]

    return parsed


def _docker_parse_table(rows, fields, keys):
    '''docker provides us with space separated tables with field containing spaces

    e.g.:

    TYPE           TOTAL  ACTIVE   SIZE       RECLAIMABLE
    Images         7      6        2.076 GB   936.9 MB (45%)
    Containers     22     0        2.298 GB   2.298 GB (100%)
    Local Volumes  5      5        304 B      0 B (0%)
    '''
    if not rows or not rows[0]:
        return []

    indices = []
    for field in fields:
        rex = regex(field + r'\ *')
        m = rex.search(rows[0][0])
        if m is not None:
            start, end = m.start(), m.end()
            if end - start == len(field):
                end = None
            indices.append((start, end))
        else:
            indices.append((0, 0))

    table = []
    for row in rows[1:]:
        if not row:
            continue
        try:
            line = {k: row[0][i:j].strip() for k, (i, j) in zip(keys, indices)}
        except IndexError:
            continue
        table.append(line)

    return table


def parse_docker_system_df(info):

    field_map = (
        ('TYPE', 'TOTAL', 'ACTIVE', 'SIZE', 'RECLAIMABLE'),
        ('Type', 'TotalCount', 'Active', 'Size', 'Reclaimable'),
        (str, int, int, _docker_get_bytes, _docker_get_bytes),
    )

    try:  # parse legacy json output: from 1.5.0 - 1.5.0p6
        table = [json.loads(",".join(row)) for row in info if row]
    except ValueError:
        table = _docker_parse_table(info, field_map[0], field_map[1])

    parsed = {}
    for line in table:
        for key, type_ in zip(field_map[1], field_map[2]):
            v = line.get(key)
            if v is not None:
                line[key] = type_(v)
        parsed[line.get("Type").lower()] = line

    return parsed


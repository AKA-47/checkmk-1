#!/usr/bin/python
# -*- encoding: utf-8; py-indent-offset: 4 -*-
# +------------------------------------------------------------------+
# |             ____ _               _        __  __ _  __           |
# |            / ___| |__   ___  ___| | __   |  \/  | |/ /           |
# |           | |   | '_ \ / _ \/ __| |/ /   | |\/| | ' /            |
# |           | |___| | | |  __/ (__|   <    | |  | | . \            |
# |            \____|_| |_|\___|\___|_|\_\___|_|  |_|_|\_\           |
# |                                                                  |
# | Copyright Mathias Kettner 2018             mk@mathias-kettner.de |
# +------------------------------------------------------------------+
#
# This file is part of Check_MK.
# The official homepage is at http://mathias-kettner.de/check_mk.
#
# check_mk is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# tails. You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.
import json


def _docker_get_bytes(string):
    '''get number of bytes from string

    e.g.
    "123GB (42%)" -> 123000000000
    "0 B"         -> 0
    "2B"          -> 2
    "23 kB"       -> 23000
    '''
    # remove percent
    string = string.split('(')[0].strip()
    value_string = string.rstrip('kKMGB').strip()
    unit_string = string.lstrip('0123456789.').strip()
    try:
        factor = {
            'GB': 10**9,
            'MB': 10**6,
            'kB': 10**3,
        }.get(unit_string, 1)
        return int(float(value_string) * factor)
    except (ValueError, TypeError):
        return None


def _docker_trunc_id(hash_string):
    '''normalize to short ID

    Some docker commands use shortened, some long IDs:
    Convert long ones to short ones, e.g.
    "sha256:8b15606a9e3e430cb7ba739fde2fbb3734a19f8a59a825ffa877f9be49059817"
    to
    "8b15606a9e3e"
    '''
    long_id = hash_string.split(':', 1)[-1]
    return long_id[:12]


#   .--parse---------------------------------------------------------------.
#   |                                                                      |
#   |                      _ __   __ _ _ __ ___  ___                       |
#   |                     | '_ \ / _` | '__/ __|/ _ \                      |
#   |                     | |_) | (_| | |  \__ \  __/                      |
#   |                     | .__/ \__,_|_|  |___/\___|                      |
#   |                     |_|                                              |
#   +----------------------------------------------------------------------+
#   |                                                                      |
#   '----------------------------------------------------------------------'


def _get_json(info):
    try:
        return json.loads(''.join(row[0] for row in info if row))
    except ValueError:
        return None


def _docker_parse_table(rows, fields, keys):
    '''docker provides us with space separated tables with field containing spaces

    e.g.:

    TYPE           TOTAL  ACTIVE   SIZE       RECLAIMABLE
    Images         7      6        2.076 GB   936.9 MB (45%)
    Containers     22     0        2.298 GB   2.298 GB (100%)
    Local Volumes  5      5        304 B      0 B (0%)
    '''
    if not rows or not rows[0]:
        return []

    indices = []
    for field in fields:
        rex = regex(field + r'\ *')
        m = rex.search(rows[0][0])
        if m is not None:
            start, end = m.start(), m.end()
            if end - start == len(field):
                end = None
            indices.append((start, end))
        else:
            indices.append((0, 0))

    table = []
    for row in rows[1:]:
        if not row:
            continue
        try:
            line = {k: row[0][i:j].strip() for k, (i, j) in zip(keys, indices)}
        except IndexError:
            continue
        table.append(line)

    return table


def parse_docker_node_info(info):
    '''parse output of "docker info"'''
    try:
        return json.loads(":".join(info[0]))
    except ValueError:
        pass

    parsed = {}
    prefix = ""
    for row in info:
        if not row:
            continue
        # remove '|', it was protecting leading whitespace
        row[0] = row[0][1:]
        if not row[0]:
            continue
        # ignore misssing keys / pad lines that are not of "key: value" type
        if len(row) == 1:
            row.append('')
        key = row[0].strip()
        value = ':'.join(row[1:]).strip()
        # indented keys are prefixed by the last not indented key
        # this does the right thing in the cases we use
        indent = len(row[0]) - len(key)
        if indent == 0:
            parsed[key] = value
            prefix = key
        else:
            parsed[prefix + key] = value

    # reconstruct labels (they where not in "k: v" format)
    parsed["Labels"] = []
    for k in parsed.keys():  # pylint: disable=C0201
        if k.startswith("Labels") and k != "Labels":
            parsed["Labels"].append(k[6:] + parsed.pop(k))

    return parsed


def parse_docker_system_df(info):
    parsed = {}
    header = ('TYPE', 'TOTAL', 'ACTIVE', 'SIZE', 'RECLAIMABLE')
    keys = ('Type', 'TotalCount', 'Active', 'Size', 'Reclaimable')
    types = (str, int, int, _docker_get_bytes, _docker_get_bytes)
    table = _docker_parse_table(info, header, keys)

    for line in table:
        for key, type_ in zip(keys, types):
            v = line.get(key)
            if v is not None:
                line[key] = type_(v)
        parsed[line.get("Type").lower()] = line

    return parsed


def parse_docker_images(info):
    parsed = {}
    header = ('REPOSITORY', 'TAG', r'IMAGE\ ID', 'CREATED', 'SIZE')
    keys = ('Repository', 'Tag', 'ID', 'CreatedAt', 'VirtualSize')
    table = _docker_parse_table(info, header, keys)

    for item in table:
        v = item.get("VirtualSize")
        if v is not None:
            item["VirtualSize"] = _docker_get_bytes(v)
        parsed[item.get("ID")] = item

    return parsed


def parse_docker_image_inspect(info):
    data = _get_json(info)
    if data is None:
        return []
    return data


def parse_docker_ps_all(info):
    header = (r'CONTAINER\ ID', 'IMAGE', 'COMMAND', 'CREATED', 'STATUS', 'PORTS', 'NAMES')
    keys = ('ID', 'Image', 'Command', 'CreatedAt', 'Status', 'Ports', 'Names')
    table = _docker_parse_table(info, header, keys)

    parsed = {}
    for item in table:
        image_name = item["Image"]
        if ":" in image_name:
            item["Repository"], item["Tag"] = image_name.split(":", 1)
        else:
            item["Repository"], item["Tag"] = image_name, "latest"
        parsed[item.get("ID")] = item

    return parsed


def _split_subsections(info):
    subname = ''
    subsections = {}
    for row in info:
        if not row:
            continue
        if row[0].startswith('[[[') and row[0].endswith(']]]'):
            subname = row[0].strip('[]')
            continue
        subsections.setdefault(subname,  []).append(row)
    return subsections


def parse_docker_node_images(info):
    '''parse output of <<<docker_node_images>>>

    $ echo "[[[images]]]"
    $ docker images
    $ echo "[[[image_labels]]]"
    $ IMAGE_IDS=$(docker images ls | awk 'BEGIN {ORF=" "} NR>1 {print $3}')
    $ docker image inspect $IMAGE_IDS
    $ echo "[[[containers]]]"
    $ docker ps --all
    '''
    subsections = _split_subsections(info)

    images = parse_docker_images(subsections.get("images", []))
    label_data = parse_docker_image_inspect(subsections.get("images_labels", []))
    containers = parse_docker_ps_all(subsections.get("containers", []))

    for item in label_data:
        image_id = _docker_trunc_id(item.get("Id"))
        labels = item.get("Config", {}).get("Labels")
        image = images.get(image_id)
        if None not in (image_id, labels, image):
            image.setdefault("__labels__", {}).update(labels)

    mapping = {(i['Repository'], i['Tag']): i['ID'] for i in images.itervalues()}
    for c in containers.itervalues():
        image_id = mapping.get((c["Repository"], c["Tag"]))
        image = images.get(image_id)
        if image is not None:
            image.setdefault("__containers__", []).append(c)

        labels = c.get("Labels")
        if labels is not None:
            lab = (p.split("=", 1) for p in labels.split(","))
            c["Labels"] = list(lab)

    return {"images": images, "containers": containers}


def parse_docker_network_inspect(info):
    data = _get_json(info)
    if data is None:
        return []
    return data

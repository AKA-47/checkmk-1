#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright (C) 2019 tribe29 GmbH - License: GNU General Public License v2
# This file is part of Checkmk (https://checkmk.com). It is subject to the terms and
# conditions defined in the file COPYING, which is part of this source code package.

from cmk.base.check_legacy_includes.cpu_util import *  # pylint: disable=wildcard-import,unused-wildcard-import
import cmk.base.plugins.agent_based.winperf_processor

Section = cmk.base.plugins.agent_based.winperf_processor.Section

winperf_cpu_default_levels = {}  # old discovery refered to variable by name!


def inventory_winperf_util(section: Section):
    if section.ticks:
        yield None, {}


def _clamp_percentage(value):
    '''clamp percentage to the range 0-100

    Due to timing invariancies the measured level can become > 100%.
    This makes users unhappy, so cut it off.
    '''
    return min(100.0, max(0.0, value))


def _get_secs_per_sec(ticks, key, this_time, wrapped):
    try:
        ticks_per_sec =\
            get_rate("winperf_util.%s" % key, this_time, ticks, onwrap=RAISE)
    except MKCounterWrapped:
        return True, 0.0
    # 1 tick = 100ns, convert to seconds
    return wrapped, ticks_per_sec / 10000000.0


def check_winperf_util(_no_item, params, section: Section):
    wrapped = False
    for ticks in section.ticks:

        wrapped, cpusecs_per_sec = _get_secs_per_sec(ticks.total, ticks.name, section.time, wrapped)
        if ticks.name != "util":
            yield check_levels(
                _clamp_percentage(100.0 * cpusecs_per_sec),
                ticks.name,
                None,
                human_readable_func=get_percent_human_readable,
                infoname=ticks.name.capitalize(),
            )
            continue

        # We get the value of the PERF_100NSEC_TIMER_INV here.
        # This counter type shows the average percentage of active time observed
        # during the sample interval. This is an inverse counter. Counters of this
        # type calculate active time by measuring the time that the service was
        # inactive and then subtracting the percentage of active time from 100 percent.
        used_perc = _clamp_percentage(100.0 * (1 - cpusecs_per_sec))
        cores = []
        for idx, core_ticks in enumerate(ticks.per_core):
            wrapped, core_cpusecs_per_sec = _get_secs_per_sec(core_ticks, "core%d.util" % idx,
                                                              section.time, wrapped)
            core_used_perc = _clamp_percentage(100.0 * (1 - core_cpusecs_per_sec))
            cores.append(("core%d" % idx, core_used_perc))

        if not wrapped:
            for subresult in check_cpu_util(used_perc, params, section.time, cores):
                if len(subresult) == 3 and subresult[2]:
                    perf = subresult[2]
                    if perf[0][0] == "util":
                        perf[0] = perf[0][:5] + (len(cores),)
                yield subresult

    if wrapped:
        # all counters initialized, NOW we can raise the exception
        raise MKCounterWrapped("Counter wrap, skipping checks this time")

    try:
        yield 0, "%d CPUs" % len(cores), [('cpus', len(cores))]
    except NameError:
        pass


check_info["winperf_processor.util"] = {
    'check_function': check_winperf_util,
    'inventory_function': inventory_winperf_util,
    'service_description': 'CPU utilization',
    'has_perfdata': True,
    'handle_real_time_checks': True,
    'group': 'cpu_utilization_os',
}

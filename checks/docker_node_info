#!/usr/bin/python
# -*- encoding: utf-8; py-indent-offset: 4 -*-
# +------------------------------------------------------------------+
# |             ____ _               _        __  __ _  __           |
# |            / ___| |__   ___  ___| | __   |  \/  | |/ /           |
# |           | |   | '_ \ / _ \/ __| |/ /   | |\/| | ' /            |
# |           | |___| | | |  __/ (__|   <    | |  | | . \            |
# |            \____|_| |_|\___|\___|_|\_\___|_|  |_|_|\_\           |
# |                                                                  |
# | Copyright Mathias Kettner 2018             mk@mathias-kettner.de |
# +------------------------------------------------------------------+
#
# This file is part of Check_MK.
# The official homepage is at http://mathias-kettner.de/check_mk.
#
# check_mk is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# tails. You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.


# TODO: see why it's not enough to have it in legacy_docker.include
def append_deprecation_warning(check_function):
    '''A wrapper to WARN if legacy code is used

    If the parse result is of one of the legacy Types the decorated
    check function will yield an additional WARNING state.

    These legacy parse results correspond to agents/plugins from version
    1.5.0b1 to 1.5.0p12
    '''

    @functools.wraps(check_function)
    def wrapper(item, params, parsed):

        is_deprecated = isinstance(parsed, (DeprecatedDict, DeprecatedList))
        catch_these = Exception if is_deprecated else ()

        try:
            results = check_function(item, params, parsed)
            if isinstance(results, tuple):
                yield results
            else:
                for result in results:
                    yield result
        except catch_these:
            yield 3, "Could not handle data"
        finally:
            if is_deprecated:
                yield 1, ("Deprecated plugin/agent (see long output)(!)\n"
                          "You are using legacy code, which may lead to crashes and/or"
                          " incomplete information. Please upgrade the monitored host to"
                          " use the plugin 'mk_docker.py'.")

    return wrapper


def parse_docker_node_info(info):
    version = docker_get_version(info)  # pylint: disable=undefined-variable
    if version is None:
        return parse_legacy_docker_node_info(info)  # pylint: disable=undefined-variable

    if len(info) < 2:
        return {}

    loaded = {}
    for line in info[1:]:
        loaded.update(docker_json_get_obj(line) or {})  # pylint: disable=undefined-variable
    return loaded


@append_deprecation_warning  # pylint: disable=undefined-variable
def check_docker_node_info(_no_item, _no_params, parsed):
    if "Name" in parsed:
        yield 0, 'Daemon running on host %s' % parsed["Name"]
    for state, key in enumerate(("Warning", "Critical", "Unknown"), 1):
        if key in parsed:
            yield state, parsed[key]


check_info['docker_node_info'] = {
    'includes': ['docker.include', 'legacy_docker.include'],
    'parse_function': parse_docker_node_info,
    'inventory_function': discover_single,
    'check_function': check_docker_node_info,
    'service_description': 'Docker node info',
}


@append_deprecation_warning  # pylint: disable=undefined-variable
def check_docker_node_containers(_no_item, params, parsed):
    def check_node_levels(count, levels, levels_lower):
        warn, crit = levels
        warn_lower, crit_lower = levels_lower
        if crit is not None and count >= crit:
            return 2, " (warn/crit at %s/%s)" % (warn, crit)
        if crit_lower is not None and count < crit_lower:
            return 2, " (warn/crit below %s/%s)" % (warn_lower, crit_lower)
        if warn is not None and count >= warn:
            return 1, " (warn/crit at %s/%s)" % (warn, crit)
        if warn_lower is not None and count < warn_lower:
            return 1, " (warn/crit below %s/%s)" % (warn_lower, crit_lower)
        return 0, ""

    for title, key, levels_prefix in (
        ("containers", "Containers", ''),
        ("running", "ContainersRunning", 'running_'),
        ("paused", "ContainersPaused", 'paused_'),
        ("stopped", "ContainersStopped", 'stopped_'),
    ):

        count = parsed.get(key)
        if count is None:
            yield 3, "%s: count not present in agent output" % title
            continue

        levels = params.get('%supper_levels' % levels_prefix, (None, None))
        levels_lower = params.get('%slower_levels' % levels_prefix, (None, None))

        status, level_text = check_node_levels(count, levels, levels_lower)
        infotext = "%s: %d%s" % (title, count, level_text)
        perfdata = [(title, count) + levels]

        yield status, infotext, perfdata


check_info["docker_node_info.containers"] = {
    "inventory_function": discover_single,
    "check_function": check_docker_node_containers,
    "service_description": "Docker containers",
    "has_perfdata": True,
    "group": "docker_node_containers",
    'includes': ['docker.include', 'legacy_docker.include'],
}

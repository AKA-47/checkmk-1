#!/usr/bin/python
# -*- encoding: utf-8; py-indent-offset: 4 -*-
# +------------------------------------------------------------------+
# |             ____ _               _        __  __ _  __           |
# |            / ___| |__   ___  ___| | __   |  \/  | |/ /           |
# |           | |   | '_ \ / _ \/ __| |/ /   | |\/| | ' /            |
# |           | |___| | | |  __/ (__|   <    | |  | | . \            |
# |            \____|_| |_|\___|\___|_|\_\___|_|  |_|_|\_\           |
# |                                                                  |
# | Copyright Mathias Kettner 2014             mk@mathias-kettner.de |
# +------------------------------------------------------------------+
#
# This file is part of Check_MK.
# The official homepage is at http://mathias-kettner.de/check_mk.
#
# check_mk is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 2.  check_mk is  distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# tails. You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.

# Common file for all (modern) checks that check CPU utilization (not load!)

# Example for check parameters:
# 1. Variant: Tuple (warn, crit). This is legacy style
# 2. Variant: dictionary:
#
#  param = {
#     "levels" : .... --> compatible with check_levels(), optional
#     "average" : 15 # -> compute average for 15 minutes, optional
#   }


# normalize name of a cpu core so that the perfdata-template
# recognizes it. If the input name doesn't end on a number, this
# returns consecutive numbers per call so this function has to be
# called exactly once per core
def cpu_util_core_name(orig, core_index):
    expr = regex(r"\d+$")
    match = expr.search(orig)
    if match is not None:
        num = match.group(0)
    else:
        # fallback: if the cores have odd names, use
        # consecutive numbers for each call
        num = core_index
    return "cpu_core_util_%s" % num


def transform_cpu_info(element):
    int_casted_entries = [element[0]] + map(int, element[1:])
    return int_casted_entries + [0] * (11 - len(int_casted_entries))


def check_cpu_util(util, params, this_time=None, cores=None, perf_max=100):
    # Convert legacy param style to new dict style
    if params is None:
        params = {}
    elif isinstance(params, tuple):
        params = {"levels": params}

    if this_time is None:
        this_time = time.time()

    levels = params.get("util")
    if levels is None:  # legacy rules before 1.6
        levels = params.get("levels")

    warn, crit = levels if isinstance(levels, tuple) else (None, None)  # only for perfdata
    perfdata = [("util", util, warn, crit, 0, perf_max)]

    # Averaging
    if "average" in params:
        util_avg = get_average("cpu_utilization.avg", this_time, util, params["average"])
        perfdata.append(("util_average", util_avg, warn, crit, 0, perf_max))
        state, infotext, extraperf = check_levels(
            util_avg,
            "util_average",
            levels,
            human_readable_func=get_percent_human_readable,
            infoname="%dmin average")
    else:
        state, infotext, extraperf = check_levels(
            util,
            "util",
            levels,
            human_readable_func=get_percent_human_readable,
            infoname="total cpu")

    perfdata += extraperf[1:]  # reference curve for predictive levels
    yield state, infotext, perfdata

    if "core_util_time_total" in params:
        threshold, warn, crit = params["core_util_time_total"]
        yield cpu_util_time(this_time, "total", util, threshold, warn, crit)

    if cores and any([x in params for x in ["core_util_graph", "core_util_time", "levels_single"]]):
        for core_index, (core, total_perc) in enumerate(cores):
            for perfdata in util_perfdata(core, total_perc, core_index, this_time, params):
                yield perfdata


# This one can handle user, system and wait. values is a list of:
# - 0 - user: normal processes executing in user mode
# - 1 - nice: niced processes executing in user mode
# - 2 - system: processes executing in kernel mode
# - 3 - idle: twiddling thumbs
# - 4 - iowait: waiting for I/O to complete
# - 5 - irq: servicing interrupts
# - 6 - softirq: servicing softirqs
# - 7 - steal: involuntary wait
# - 8 - guest: time spent in guest OK, also counted in 0 (user)
# - 9 - guest_nice: time spent in niced guest OK, also counted in 1 (nice)
def check_cpu_util_unix(values, params, cores=None):
    this_time = time.time()
    # Compute jiffi-differences of all relevant counters
    diff_values = []
    for n, v in enumerate(values):
        countername = "cpu.util.%d" % (n + 1)
        last_val = get_item_state(countername, (0, 0))[1]
        diff_values.append(v - last_val)
        set_item_state(countername, (this_time, v))

    sum_jiffies = sum(diff_values)
    if sum_jiffies == 0:
        raise MKCounterWrapped("Too short time difference since last check")

    user = diff_values[0] + diff_values[1]  # add user + nice
    # https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/kernel/sched/cputime.c
    # see 'account_guest_time'
    # if task_nice(p) <= 0:
    #     cpustat[CPUTIME_USER] += cputime;
    #     cpustat[CPUTIME_GUEST] += cputime;
    subtrahend = diff_values[8] + diff_values[9]
    user -= subtrahend
    sum_jiffies -= subtrahend

    user_perc = 100.0 * float(user) / float(sum_jiffies)
    yield 0, "user: %.1f%%" % user_perc, [("user", user_perc)]

    system = diff_values[2] + diff_values[5] + diff_values[6]
    system_perc = 100.0 * float(system) / float(sum_jiffies)
    yield 0, "system: %.1f%%" % system_perc, [("system", system_perc)]

    # Handle level on iowait
    wait = diff_values[4]
    wait_perc = 100.0 * float(wait) / float(sum_jiffies)

    yield check_levels(
        wait_perc, 'wait', params.get('iowait'), human_readable_func=get_percent_human_readable)

    # Compute values used in virtualized environments (Xen, etc.)
    # Only do this for counters that have counted at least one tick
    # since the system boot. This avoids silly output in systems
    # where these counters are not being used
    steal = diff_values[7]
    steal_perc = 100.0 * float(steal) / float(sum_jiffies)
    yield check_levels(
        steal_perc, "steal", params.get('steal'), human_readable_func=get_percent_human_readable)

    guest = diff_values[8] + diff_values[9]
    guest_perc = 100.0 * float(guest) / float(sum_jiffies)
    yield 0, "guest: %.1f%%" % guest_perc, [("guest", guest_perc)]

    # Total utilization
    util_total_perc = user_perc + system_perc + wait_perc + steal_perc + guest_perc
    yield check_levels(
        util_total_perc,
        'util',
        params.get('util'),
        human_readable_func=get_percent_human_readable,
        infoname='total')

    if "core_util_time_total" in params:
        threshold, warn, crit = params["core_util_time_total"]
        yield cpu_util_time(this_time, "total", util_total_perc, threshold, warn, crit)

    if cores and any([x in params for x in ["core_util_graph", "core_util_time", "levels_single"]]):
        for core_index, (core, user, nice, system, _idle, iowait, irq, softirq, steal, _guest,
                         _guest_nice) in enumerate(cores):

            total = user + nice + system + iowait + irq + softirq + steal
            prev_total = get_item_state("cpu.util.%s.total" % core, 0)
            total_diff = total - prev_total
            set_item_state("cpu.util.%s.total" % core, total)
            total_perc = ((100.0 * total_diff) / sum_jiffies) * len(cores)

            for perfdata in util_perfdata(core, total_perc, core_index, this_time, params):
                yield perfdata


def util_perfdata(core, total_perc, core_index, this_time, params):
    if "core_util_graph" in params:
        yield 0, "", [(cpu_util_core_name(core, core_index), total_perc)]

    if "core_util_time" in params:
        threshold, warn, crit = params["core_util_time"]
        yield cpu_util_time(this_time, core, total_perc, threshold, warn, crit)

    state, infotext, _ = check_levels(
        total_perc,
        "Core %s" % core,
        params.get('levels_single'),
        human_readable_func=get_percent_human_readable)
    if state:
        yield state, infotext, []


#   .--helper--------------------------------------------------------------.
#   |                    _          _                                      |
#   |                   | |__   ___| |_ __   ___ _ __                      |
#   |                   | '_ \ / _ \ | '_ \ / _ \ '__|                     |
#   |                   | | | |  __/ | |_) |  __/ |                        |
#   |                   |_| |_|\___|_| .__/ \___|_|                        |
#   |                                |_|                                   |
#   '----------------------------------------------------------------------'


def cpu_util_time(this_time, core, perc, threshold, warn_core, crit_core):
    core_state_name = "cpu.util.core.high.%s" % core
    if perc > threshold:
        timestamp = get_item_state(core_state_name, 0)
        high_load_duration = (this_time - timestamp)
        state, infotext, _ = check_levels(
            high_load_duration,
            "%s is under high load for" % core, (warn_core, crit_core),
            human_readable_func=get_age_human_readable)
        if timestamp == 0:
            set_item_state(core_state_name, this_time)
        elif state:
            return state, infotext
        return 0, ""

    clear_item_state(core_state_name)
    return 0, ""

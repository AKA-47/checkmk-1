#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright (C) 2019 tribe29 GmbH - License: GNU General Public License v2
# This file is part of Checkmk (https://checkmk.com). It is subject to the terms and
# conditions defined in the file COPYING, which is part of this source code package.

# <<<netapp_api_vf_snapvault:sep(9)>>>
# snapvault /vol/ipb_datap/   status idle state snapvaulted   lag-time 53812  source-system 172.31.12.15
# snapvault /vol/ipb_datas/   status idle state snapvaulted   lag-time 53812  source-system 172.31.12.15
# snapvault /vol/ipb_user/    status idle state snapvaulted   lag-time 97007  source-system 172.31.12.15
# snapvault /vol/ipb_vol0/    status idle state snapvaulted   lag-time 97011  source-system 172.31.12.15

import typing

discovery_snapvault = []


def _cleanse_item_name(name):
    return name.replace("$", "_")


def parse_netapp_api_snapvault(info):
    parsed = {}
    for line in info:
        parsed_line = dict(tuple(i.split(' ', 1)) for i in line)
        # Whether the item will be named after the snapvault or destination-location
        # values depends on the user's configuration (discovery parameters). For simplicity,
        # the same line is referenced to both in the parsed dictionary, so that the items
        # can easily be retrieved using the .get method, without needing to worry
        # about what the discovery parameters are.
        parsed[_cleanse_item_name(parsed_line['snapvault'])] = parsed_line
        if 'destination-location' in parsed_line:
            # 7mode netapp data comes without destination-location. We currently do not have
            # a test case for this.
            parsed[_cleanse_item_name(parsed_line['destination-location'])] = parsed_line
    return parsed


def _discovery_snapvault():
    params = host_extra_conf_merged(host_name(), discovery_snapvault)
    if not params:
        return {'exclude_destination_vserver': False}
    return params


def _prefilter_items(parsed, exclude_vserver):
    if exclude_vserver:
        return [i for i in parsed.items() if ':' not in i[0]]
    return [i for i in parsed.items() if ':' in i[0] or 'destination-location' not in i[1]]


def discover_netapp_api_snapvault(parsed):
    params = _discovery_snapvault()
    for snapvault, values in _prefilter_items(parsed, params['exclude_destination_vserver']):
        if "lag-time" in values:
            yield snapvault, {}


def check_netapp_api_snapvault(item, params, parsed):
    snapvault = parsed.get(item)
    if not snapvault:
        return

    for key in ["source-system", "destination-system", "policy", "status", "state"]:
        if key in snapvault:
            yield 0, "%s: %s" % (key.title(), snapvault[key])

    if 'lag-time' not in snapvault:
        return

    lag_time = int(snapvault['lag-time'])

    policy_lag_time = typing.OrderedDict(params.get('policy_lag_time', []))
    levels = policy_lag_time.get(snapvault.get('policy'))

    if not levels:
        levels = params.get('lag_time', (None, None))

    yield check_levels(
        lag_time,
        None,
        levels,
        human_readable_func=get_age_human_readable,
        infoname='Lag Time',
    )


check_info["netapp_api_snapvault"] = {
    'parse_function': parse_netapp_api_snapvault,
    'check_function': check_netapp_api_snapvault,
    'inventory_function': discover_netapp_api_snapvault,
    'group': "snapvault",
    'service_description': 'Snapvault %s',
}
